<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patient Setup - HeyDok Video</title>
    
    <!-- Tesseract.js for real OCR processing -->
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js"></script>
    
    <!-- OpenCV.js for computer vision card detection -->
    <script async src="https://docs.opencv.org/4.8.0/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2rem;
        }

        .container {
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            max-width: 800px;
            width: 100%;
            overflow: hidden;
        }

        .header {
            background: #4a90e2;
            color: white;
            padding: 2rem;
            text-align: center;
        }

        .header-logo {
            max-width: 200px;
            height: auto;
            margin-bottom: 1rem;
            filter: brightness(0) invert(1);
        }

        .header h1 {
            margin-bottom: 0.5rem;
            font-size: 2rem;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1rem;
        }

        .content {
            padding: 2rem;
        }

        .step {
            margin-bottom: 2rem;
            padding: 1.5rem;
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            transition: all 0.3s ease;
        }

        .step.active {
            border-color: #4a90e2;
            background: #f8f9ff;
        }

        .step.completed {
            border-color: #4caf50;
            background: #f1f8e9;
        }

        .step-header {
            display: flex;
            align-items: center;
            margin-bottom: 1rem;
        }

        .step-number {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: #e0e0e0;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 1rem;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .step.active .step-number {
            background: #4a90e2;
            color: white;
        }

        .step.completed .step-number {
            background: #4caf50;
            color: white;
        }

        .step-title {
            font-size: 1.2rem;
            font-weight: 600;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: #333;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s ease;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #4a90e2;
        }

        .file-upload {
            border: 2px dashed #e0e0e0;
            border-radius: 8px;
            padding: 2rem;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .file-upload:hover {
            border-color: #4a90e2;
            background: #f8f9ff;
        }

        .file-upload.drag-over {
            border-color: #4a90e2;
            background: #f0f8ff;
        }

        .file-upload input {
            display: none;
        }

        .file-upload-text {
            margin-top: 1rem;
            color: #666;
        }

        .media-test {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .media-preview {
            flex: 1;
            background: #f5f5f5;
            border-radius: 8px;
            padding: 1rem;
            text-align: center;
            min-height: 200px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .media-preview video {
            width: 100%;
            max-width: 300px;
            height: auto;
            border-radius: 8px;
        }

        .audio-level {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            margin-top: 1rem;
            overflow: hidden;
        }

        .audio-level-bar {
            height: 100%;
            background: linear-gradient(90deg, #4caf50, #ffc107, #f44336);
            width: 0%;
            transition: width 0.1s ease;
        }

        .checkbox-group {
            margin: 1rem 0;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .checkbox-item input[type="checkbox"] {
            width: auto;
            margin-right: 0.5rem;
        }

        .btn {
            background: #4a90e2;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
        }

        .btn:hover {
            background: #357abd;
            transform: translateY(-2px);
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .btn-success {
            background: #4caf50;
        }

        .btn-success:hover {
            background: #45a049;
        }

        .status-message {
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
        }

        .status-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status-warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #4a90e2;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 0.5rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .final-step {
            text-align: center;
            padding: 2rem;
        }

        .final-step .btn {
            font-size: 1.2rem;
            padding: 1rem 2rem;
        }

        /* Insurance Card Scanner Styles */
        .insurance-validation {
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }

        .validation-step {
            text-align: center;
        }

        /* NEW: Two-Step Scanning Styles */
        .card-scanning-steps {
            text-align: center;
        }

        .scanning-step {
            margin-bottom: 2rem;
        }

        .step-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding: 1rem;
            background: #f8f9fa;
            border-radius: 8px;
            border: 2px solid #e9ecef;
        }

        .step-indicator {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .step-number {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: #4a90e2;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.1rem;
        }

        .step-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #333;
        }

        .step-progress {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .progress-bar {
            width: 120px;
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4a90e2, #357abd);
            transition: width 0.3s ease;
            border-radius: 4px;
        }

        .progress-text {
            font-size: 0.85rem;
            color: #666;
            white-space: nowrap;
        }

        .card-side-indicator {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            background: #4a90e2;
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        .automatic-card-detection {
            text-align: center;
        }

        .card-scanner {
            position: relative;
            display: inline-block;
            margin-bottom: 1rem;
        }

        .scanner-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .card-frame {
            position: relative;
            width: 280px;
            height: 180px;
            border: 2px solid #4a90e2;
            border-radius: 12px;
            background: rgba(74, 144, 226, 0.1);
            transition: all 0.3s ease;
        }

        /* Dynamic card frame states */
        .card-frame.detecting {
            border-color: #ffc107;
            background: rgba(255, 193, 7, 0.1);
            box-shadow: 0 0 20px rgba(255, 193, 7, 0.3);
        }

        .card-frame.detected {
            border-color: #28a745;
            background: rgba(40, 167, 69, 0.1);
            box-shadow: 0 0 20px rgba(40, 167, 69, 0.3);
        }

        .card-frame.error {
            border-color: #dc3545;
            background: rgba(220, 53, 69, 0.1);
            box-shadow: 0 0 20px rgba(220, 53, 69, 0.3);
        }

        .corner {
            position: absolute;
            width: 20px;
            height: 20px;
            border: 3px solid #4a90e2;
            transition: all 0.3s ease;
        }

        .card-frame.detecting .corner {
            border-color: #ffc107;
        }

        .card-frame.detected .corner {
            border-color: #28a745;
        }

        .card-frame.error .corner {
            border-color: #dc3545;
        }

        .corner.top-left {
            top: -3px;
            left: -3px;
            border-right: none;
            border-bottom: none;
        }

        .corner.top-right {
            top: -3px;
            right: -3px;
            border-left: none;
            border-bottom: none;
        }

        .corner.bottom-left {
            bottom: -3px;
            left: -3px;
            border-right: none;
            border-top: none;
        }

        .corner.bottom-right {
            bottom: -3px;
            right: -3px;
            border-left: none;
            border-top: none;
        }

        .scan-text {
            position: absolute;
            bottom: -30px;
            left: 50%;
            transform: translateX(-50%);
            color: #4a90e2;
            font-weight: 600;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .card-frame.detecting .scan-text {
            color: #ffc107;
        }

        .card-frame.detected .scan-text {
            color: #28a745;
        }

        .card-frame.error .scan-text {
            color: #dc3545;
        }

        /* Success confirmation bar */
        .detection-success-bar {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            height: 6px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 3px;
            overflow: hidden;
        }

        .success-progress {
            height: 100%;
            background: linear-gradient(90deg, #28a745, #20c997);
            width: 0%;
            transition: width 0.5s ease;
            border-radius: 3px;
        }

        /* OCR Progress bar */
        .ocr-progress-bar {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            height: 20px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            border: 1px solid #007bff;
            overflow: hidden;
        }

        .ocr-progress {
            height: 100%;
            background: linear-gradient(90deg, #007bff, #0056b3);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 10px;
        }

        .ocr-progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 11px;
            font-weight: 600;
            color: #333;
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.8);
            z-index: 1;
        }

        .scan-status {
            margin: 1rem 0;
            padding: 0.5rem;
            border-radius: 4px;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .scan-status.loading {
            background: #fff3cd;
            color: #856404;
        }

        .scan-status.detecting {
            background: #fff3cd;
            color: #856404;
        }

        .scan-status.success {
            background: #d4edda;
            color: #155724;
        }

        .scan-status.error {
            background: #f8d7da;
            color: #721c24;
        }

        /* Card type info */
        .card-type-info {
            margin: 1rem 0;
        }

        .info-badge {
            display: inline-block;
            padding: 0.5rem 1rem;
            background: #e3f2fd;
            color: #1976d2;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
        }

        /* Data confirmation section */
        .data-confirmation {
            text-align: center;
            padding: 2rem;
            background: #f8f9fa;
            border-radius: 12px;
            border: 2px solid #28a745;
        }

        .confirmation-header h4 {
            margin-bottom: 1rem;
        }

        .extracted-data {
            background: white;
            padding: 1.5rem;
            border-radius: 8px;
            margin: 1rem 0;
            text-align: left;
        }

        .data-field {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
            border-bottom: 1px solid #eee;
        }

        .data-field:last-child {
            border-bottom: none;
        }

        .data-label {
            font-weight: 600;
            color: #333;
        }

        .data-value {
            color: #666;
            font-family: monospace;
        }

        .confirmation-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        .confirmation-buttons .btn {
            min-width: 120px;
        }

        /* Error guidance section */
        .error-guidance {
            text-align: center;
            padding: 2rem;
            background: #fff3cd;
            border-radius: 12px;
            border: 2px solid #ffc107;
        }

        .guidance-content h4 {
            color: #856404;
            margin-bottom: 1rem;
        }

        .guidance-content ul {
            color: #856404;
            max-width: 300px;
            margin: 1rem auto;
        }

        .guidance-content li {
            margin-bottom: 0.5rem;
        }

        .validation-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin: 1rem 0;
        }

        .validation-progress {
            height: 100%;
            background: linear-gradient(90deg, #4caf50, #66bb6a);
            width: 0%;
            transition: width 0.5s ease;
            border-radius: 4px;
        }

        .validation-success {
            text-align: center;
            padding: 2rem;
        }

        /* NEW: Automatic Processing Styles */
        .auto-processing {
            text-align: center;
            padding: 1.5rem;
            background: #f8f9fa;
            border-radius: 12px;
            border: 2px solid #28a745;
            margin: 1rem 0;
        }

        .auto-scan-countdown {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }

        .countdown-circle {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: linear-gradient(135deg, #28a745, #20c997);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            animation: pulse 1s infinite;
        }

        .countdown-number {
            font-size: 2rem;
            font-weight: bold;
            color: white;
        }

        @keyframes pulse {
            0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(40, 167, 69, 0.7); }
            70% { transform: scale(1.05); box-shadow: 0 0 0 10px rgba(40, 167, 69, 0); }
            100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(40, 167, 69, 0); }
        }

        /* Quality Guidance Styles */
        .quality-guidance {
            text-align: center;
            padding: 1.5rem;
            background: #fff3cd;
            border-radius: 12px;
            border: 2px solid #ffc107;
            margin: 1rem 0;
        }

        .guidance-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }

        .guidance-text {
            font-size: 1.1rem;
            font-weight: 600;
            color: #856404;
            margin-bottom: 1rem;
        }

        .guidance-tips {
            display: flex;
            justify-content: center;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .tip {
            background: rgba(255, 193, 7, 0.2);
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.9rem;
            color: #856404;
            border: 1px solid rgba(255, 193, 7, 0.3);
        }

        /* Enhanced card frame animations */
        .card-frame.auto-detected {
            border-color: #20c997;
            background: rgba(32, 201, 151, 0.15);
            box-shadow: 0 0 30px rgba(32, 201, 151, 0.4);
            animation: cardDetected 0.5s ease;
        }

        @keyframes cardDetected {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }

        /* Smooth transitions */
        .scanning-step {
            transition: all 0.5s ease;
        }

        .card-scanner {
            transition: all 0.3s ease;
        }

        .auto-processing {
            animation: slideIn 0.5s ease;
        }

        .quality-guidance {
            animation: slideIn 0.5s ease;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Progressive enhancement styles */
        .enhanced-detection {
            position: relative;
        }

        .enhanced-detection::after {
            content: '🤖 KI-Erkennung aktiv';
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(74, 144, 226, 0.9);
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 600;
        }

        /* Countdown indicator styles */
        .countdown-indicator {
            transition: all 0.3s ease;
            animation: countdownPulse 1s ease-in-out infinite;
        }

        @keyframes countdownPulse {
            0% { transform: scale(1); opacity: 0.9; }
            50% { transform: scale(1.05); opacity: 1; }
            100% { transform: scale(1); opacity: 0.9; }
        }

        @media (max-width: 768px) {
            .media-test {
                flex-direction: column;
            }
            
            .container {
                margin: 1rem;
            }
            
            .card-frame {
                width: 240px;
                height: 150px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <img src="/static/heydok_logo.svg" alt="HeyDok Logo" class="header-logo">
            <h1>Patient Setup</h1>
            <p>Vorbereitung für Ihre Sprechstunde</p>
        </div>

        <div class="content">
            <!-- Step 1: Patient Information -->
            <div class="step active" id="step1">
                <div class="step-header">
                    <div class="step-number">1</div>
                    <div class="step-title">Patienteninformationen</div>
                </div>
                <div class="form-group">
                    <label for="patientName">Ihr Name:</label>
                    <input type="text" id="patientName" placeholder="Max Mustermann" required>
                </div>
                <button class="btn" onclick="nextStep(1)">Weiter</button>
            </div>

            <!-- Step 2: Document Upload -->
            <div class="step" id="step2">
                <div class="step-header">
                    <div class="step-number">2</div>
                    <div class="step-title">Dokumente für den Arzt hochladen (optional)</div>
                </div>
                
                <!-- IMPROVED: Clear instructions for document upload -->
                <div style="background: #e3f2fd; border: 1px solid #2196f3; border-radius: 8px; padding: 1rem; margin-bottom: 1rem;">
                    <div style="display: flex; align-items: flex-start; gap: 0.5rem;">
                        <div style="font-size: 1.5rem; color: #2196f3;">ℹ️</div>
                        <div>
                            <strong style="color: #1976d2;">Wichtiger Hinweis:</strong><br>
                            <span style="color: #333;">
                                Bitte laden Sie <strong>ALLE Dokumente</strong> hoch, die Sie dem Arzt während der Sprechstunde zeigen möchten:
                            </span>
                            <ul style="margin: 0.5rem 0 0.5rem 1rem; color: #333;">
                                <li>Krankenkassenschein</li>
                                <li>Überweisungen</li>
                                <li>Befunde, Laborwerte</li>
                                <li>Röntgenbilder, MRT-Aufnahmen</li>
                                <li>Medikamentenlisten</li>
                            </ul>
                            <span style="color: #d32f2f; font-weight: 500;">
                                ⚠️ Während des Meetings ist kein Upload mehr möglich!
                            </span>
                        </div>
                    </div>
                </div>
                
                <p style="margin-bottom: 1rem; color: #666;">
                    Sie können mehrere Dateien nacheinander hochladen. Jede Datei wird einzeln verarbeitet.
                </p>
                
                <div class="file-upload" onclick="document.getElementById('documentFile').click()">
                    <div style="font-size: 3rem;">📄</div>
                    <div class="file-upload-text">
                        <strong>Klicken Sie hier oder ziehen Sie eine Datei hinein</strong><br>
                        PDF, JPG, PNG, DOC, DOCX (max. 10MB)
                    </div>
                    <input type="file" id="documentFile" accept=".pdf,.jpg,.jpeg,.png,.doc,.docx" onchange="handleFileSelect(event)">
                </div>
                <div id="uploadStatus"></div>
                <div style="margin-top: 1rem;">
                    <button class="btn" id="step2Next" onclick="nextStep(2)" disabled>Weiter</button>
                    <button class="btn" id="skipDocumentBtn" onclick="skipDocument()" style="background: #6c757d; margin-left: 10px;">Überspringen (keine Dokumente)</button>
                </div>
            </div>

            <!-- Step 3: Media Test -->
            <div class="step" id="step3">
                <div class="step-header">
                    <div class="step-number">3</div>
                    <div class="step-title">Kamera & Mikrofon testen</div>
                </div>
                <p style="margin-bottom: 1rem; color: #666;">
                    Testen Sie Ihre Kamera und Ihr Mikrofon, um sicherzustellen, dass alles funktioniert.
                </p>
                
                <div class="media-test">
                    <div class="media-preview">
                        <h4>Kamera Test</h4>
                        <video id="cameraPreview" autoplay muted playsinline></video>
                        <div id="cameraStatus">Kamera wird geladen...</div>
                    </div>
                    <div class="media-preview">
                        <h4>Mikrofon Test</h4>
                        <div style="font-size: 3rem; margin-bottom: 1rem;">🎤</div>
                        <div id="microphoneStatus">Mikrofon wird geladen...</div>
                        <div class="audio-level">
                            <div class="audio-level-bar" id="audioLevelBar"></div>
                        </div>
                    </div>
                </div>

                <div class="checkbox-group">
                    <div class="checkbox-item">
                        <input type="checkbox" id="confirmWorking" onchange="checkMediaTestCompletion()">
                        <label for="confirmWorking"><strong>Meine Kamera und Mikrofon funktionieren</strong></label>
                    </div>
                </div>

                <button class="btn" onclick="startMediaTest()">Test starten</button>
                <button class="btn" id="step3Next" onclick="nextStep(3)" disabled>Weiter</button>
            </div>

            <!-- Step 4: Insurance Card Validation -->
            <div class="step" id="step4">
                <div class="step-header">
                    <div class="step-number">4</div>
                    <div class="step-title">Krankenkassenkarte validieren</div>
                </div>
                
                <div style="background: #fff3cd; border: 1px solid #ffc107; border-radius: 8px; padding: 1rem; margin-bottom: 1rem;">
                    <div style="display: flex; align-items: flex-start; gap: 0.5rem;">
                        <div style="font-size: 1.5rem; color: #856404;">⚠️</div>
                        <div>
                            <strong style="color: #856404;">Warum validieren wir Ihre Karte?</strong><br>
                            <span style="color: #856404;">Dies stellt sicher, dass Sie versichert sind und beschleunigt die Abrechnung. Ihre Daten werden sicher verschlüsselt übertragen.</span>
                        </div>
                    </div>
                </div>

                <div class="insurance-validation">
                    <!-- NEU: Toggle/Tab-Selector für Scan vs. Manuelle Eingabe -->
                    <div style="display: flex; justify-content: center; margin-bottom: 2rem; gap: 1rem;">
                        <button id="toggleScan" class="btn btn-success" type="button" onclick="showScanMode()" style="min-width: 160px;">Scannen</button>
                        <button id="toggleManual" class="btn" type="button" onclick="showManualMode()" style="min-width: 160px; background: #6c757d;">Manuell eingeben</button>
                    </div>

                    <!-- Scan-Workflow (Standard) -->
                    <div id="scanWorkflow">
                    <!-- Step-by-Step Card Scanning Process -->
                    <div class="card-scanning-steps" id="cardScanningSteps">
                        
                        <!-- Step 1: Front Side Scanning -->
                        <div class="scanning-step active" id="frontSideStep">
                            <div class="step-header">
                                <div class="step-indicator">
                                    <span class="step-number">1</span>
                                    <span class="step-title">Vorderseite scannen</span>
                                </div>
                                <div class="step-progress">
                                    <div class="progress-bar">
                                        <div class="progress-fill" style="width: 50%;"></div>
                                    </div>
                                    <span class="progress-text">Schritt 1 von 2</span>
                                </div>
                            </div>
                            
                            <p style="color: #666; margin-bottom: 1rem; text-align: center;">
                                📄 Halten Sie die <strong>Vorderseite</strong> Ihrer Krankenkassenkarte bereit und starten Sie den Countdown
                            </p>
                            
                            <div class="card-scanner">
                                <video id="frontSideCamera" autoplay muted playsinline 
                                       style="width: 100%; max-width: 400px; border-radius: 8px;"></video>
                                <canvas id="frontDetectionCanvas" style="display: none;"></canvas>
                                
                                <div class="scanner-overlay">
                                    <div class="card-frame enhanced-detection" id="frontCardFrame">
                                        <div class="corner top-left"></div>
                                        <div class="corner top-right"></div>
                                        <div class="corner bottom-left"></div>
                                        <div class="corner bottom-right"></div>
                                        <div class="scan-text" id="frontCardFrameText">Vorderseite hier positionieren</div>
                                    </div>
                                </div>
                                
                                <!-- OCR Progress Bar -->
                                <div class="ocr-progress-bar" id="frontOcrProgressBar" style="display: none;">
                                    <div class="ocr-progress" id="frontOcrProgress"></div>
                                    <div class="ocr-progress-text" id="frontOcrProgressText">OCR wird vorbereitet...</div>
                                </div>
                            </div>

                            <div id="frontSideStatus" class="scan-status">Kamera wird initialisiert...</div>
                            
                            <!-- Manual Scan Button - Always Visible -->
                            <div style="text-align: center; margin: 1rem 0;">
                                <button class="btn" onclick="startCardCountdown('front')" style="background: #28a745; font-size: 1.1rem; padding: 1rem 2rem;">
                                    ⏰ Countdown starten (5 Sek.)
                                </button>
                                <p style="font-size: 0.85rem; color: #666; margin-top: 0.5rem;">
                                    Karte bereithalten, dann Countdown starten
                                </p>
                                
                                <!-- DEBUG: Test screenshot button -->
                                <button class="btn" onclick="testScreenshot('front')" style="background: #6c757d; margin-left: 10px; font-size: 0.9rem; padding: 0.5rem 1rem;">
                                    🧪 Screenshot testen
                                </button>
                            </div>
                            
                            <!-- Automatic Processing Indicator -->
                            <div id="frontAutoProcessing" class="auto-processing" style="display: none;">
                                <div class="auto-scan-countdown">
                                    <div class="countdown-circle">
                                        <div class="countdown-number" id="frontCountdownNumber">3</div>
                                    </div>
                                    <p>Automatischer Scan in <span id="frontCountdownText">3</span> Sekunden...</p>
                                </div>
                            </div>
                            
                            <!-- Quality Guidance -->
                            <div id="frontQualityGuidance" class="quality-guidance" style="display: none;">
                                <div class="guidance-icon">📸</div>
                                <div class="guidance-text" id="frontGuidanceText">Karte bitte ruhiger halten</div>
                                <div class="guidance-tips">
                                    <span class="tip">💡 Bessere Beleuchtung</span>
                                    <span class="tip">📏 Näher halten</span>
                                    <span class="tip">🎯 Im Rahmen zentrieren</span>
                                </div>
                            </div>
                        </div>

                        <!-- Step 2: Back Side Scanning -->
                        <div class="scanning-step" id="backSideStep" style="display: none;">
                            <div class="step-header">
                                <div class="step-indicator">
                                    <span class="step-number">2</span>
                                    <span class="step-title">Rückseite scannen</span>
                                </div>
                                <div class="step-progress">
                                    <div class="progress-bar">
                                        <div class="progress-fill" style="width: 100%;"></div>
                                    </div>
                                    <span class="progress-text">Schritt 2 von 2</span>
                                </div>
                            </div>
                            
                            <div style="background: #d4edda; border: 1px solid #c3e6cb; border-radius: 8px; padding: 1rem; margin-bottom: 1rem;">
                                <div style="display: flex; align-items: center; gap: 0.5rem;">
                                    <div style="font-size: 1.5rem; color: #155724;">✅</div>
                                    <div>
                                        <strong style="color: #155724;">Vorderseite erfolgreich gescannt!</strong><br>
                                        <span style="color: #155724;" id="frontSideDataPreview">Name und Versichertennummer erkannt</span>
                                    </div>
                                </div>
                            </div>
                            
                            <p style="color: #666; margin-bottom: 1rem; text-align: center;">
                                📄 Drehen Sie die Karte um, halten Sie die <strong>Rückseite</strong> bereit und starten Sie den Countdown
                            </p>
                            
                            <div class="card-scanner">
                                <video id="backSideCamera" autoplay muted playsinline 
                                       style="width: 100%; max-width: 400px; border-radius: 8px;"></video>
                                <canvas id="backDetectionCanvas" style="display: none;"></canvas>
                                
                                <div class="scanner-overlay">
                                    <div class="card-frame enhanced-detection" id="backCardFrame">
                                        <div class="corner top-left"></div>
                                        <div class="corner top-right"></div>
                                        <div class="corner bottom-left"></div>
                                        <div class="corner bottom-right"></div>
                                        <div class="scan-text" id="backCardFrameText">Rückseite hier positionieren</div>
                                    </div>
                                </div>
                                
                                <!-- OCR Progress Bar -->
                                <div class="ocr-progress-bar" id="backOcrProgressBar" style="display: none;">
                                    <div class="ocr-progress" id="backOcrProgress"></div>
                                    <div class="ocr-progress-text" id="backOcrProgressText">OCR wird vorbereitet...</div>
                                </div>
                            </div>

                            <div id="backSideStatus" class="scan-status">Kamera wird initialisiert...</div>
                            
                            <!-- Manual Scan Button - Always Visible -->
                            <div style="text-align: center; margin: 1rem 0;">
                                <button class="btn" onclick="startCardCountdown('back')" style="background: #28a745; font-size: 1.1rem; padding: 1rem 2rem;">
                                    ⏰ Countdown starten (5 Sek.)
                                </button>
                                <p style="font-size: 0.85rem; color: #666; margin-top: 0.5rem;">
                                    Karte bereithalten, dann Countdown starten
                                </p>
                                
                                <!-- DEBUG: Test screenshot button -->
                                <button class="btn" onclick="testScreenshot('back')" style="background: #6c757d; margin-left: 10px; font-size: 0.9rem; padding: 0.5rem 1rem;">
                                    🧪 Screenshot testen
                                </button>
                            </div>
                            
                            <!-- Automatic Processing Indicator -->
                            <div id="backAutoProcessing" class="auto-processing" style="display: none;">
                                <div class="auto-scan-countdown">
                                    <div class="countdown-circle">
                                        <div class="countdown-number" id="backCountdownNumber">3</div>
                                    </div>
                                    <p>Automatischer Scan in <span id="backCountdownText">3</span> Sekunden...</p>
                                </div>
                            </div>
                            
                            <!-- Quality Guidance -->
                            <div id="backQualityGuidance" class="quality-guidance" style="display: none;">
                                <div class="guidance-icon">📸</div>
                                <div class="guidance-text" id="backGuidanceText">Karte bitte ruhiger halten</div>
                                <div class="guidance-tips">
                                    <span class="tip">💡 Bessere Beleuchtung</span>
                                    <span class="tip">📏 Näher halten</span>
                                    <span class="tip">🎯 Im Rahmen zentrieren</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Error Guidance Section -->
                    <div class="error-guidance" id="errorGuidance" style="display: none;">
                        <div class="guidance-content">
                            <div style="font-size: 2rem; margin-bottom: 1rem;">📸</div>
                            <h4>Bildqualität verbessern:</h4>
                            <ul style="text-align: left; margin: 1rem 0;">
                                <li><strong>Beleuchtung:</strong> Sorgen Sie für helles, gleichmäßiges Licht</li>
                                <li><strong>Schärfe:</strong> Halten Sie die Kamera ruhig und fokussiert</li>
                                <li><strong>Abstand:</strong> Karte sollte den Rahmen vollständig ausfüllen</li>
                                <li><strong>Kontrast:</strong> Vermeiden Sie Schatten auf der Karte</li>
                                <li><strong>Sauberkeit:</strong> Reinigen Sie die Kameralinse</li>
                            </ul>
                            <button class="btn" onclick="retryCardDetection()">
                                🔄 Erneut versuchen
                            </button>
                        </div>
                    </div>
                    
                    <!-- Data Confirmation Section -->
                    <div class="data-confirmation" id="dataConfirmation" style="display: none;">
                        <div class="confirmation-header">
                            <h4 style="color: #28a745; margin-bottom: 1rem;">✅ Kartenerkennung abgeschlossen!</h4>
                        </div>
                        
                        <div class="extracted-data" id="extractedData">
                            <!-- Data will be populated by JavaScript -->
                        </div>
                        
                        <div style="background: #fff3cd; padding: 1rem; border-radius: 8px; margin: 1rem 0;">
                            <p style="margin: 0; color: #856404; font-size: 0.9rem;">
                                <strong>💡 Hinweis:</strong> Sie können diese Daten mit dem Arzt besprechen und bei Bedarf korrigieren.
                            </p>
                        </div>
                        
                        <div class="confirmation-buttons">
                            <button class="btn" onclick="confirmCardData(true)" style="background: #28a745;">
                                ✅ Daten bestätigen
                            </button>
                            <button class="btn" onclick="retryCardDetection()" style="background: #dc3545;">
                                🔄 Erneut scannen
                            </button>
                        </div>
                    </div>
                </div>

                <button class="btn" id="step4Next" onclick="nextStep(4)" disabled>Weiter</button>
            </div>

            <!-- Manuelle Eingabe (versteckt, bis aktiviert) -->
            <form id="manualInputForm" style="display: none; max-width: 400px; margin: 0 auto;">
                <div class="form-group">
                    <label for="manualKvnr">Krankenversichertennummer (KVNR):</label>
                    <input type="text" id="manualKvnr" name="manualKvnr" required pattern="[A-Za-z0-9]{10,12}" placeholder="z.B. X1234567890">
                </div>
                <div class="form-group">
                    <label for="manualName">Name des Versicherten:</label>
                    <input type="text" id="manualName" name="manualName" required minlength="2" pattern="[A-Za-zÄÖÜäöüß\-\s]+" placeholder="Max Mustermann">
                </div>
                <div class="form-group">
                    <label for="manualBirthdate">Geburtsdatum:</label>
                    <input type="date" id="manualBirthdate" name="manualBirthdate" required max="9999-12-31">
                </div>
                <div class="form-group">
                    <label for="manualInsurance">Krankenkasse (Kostenträger):</label>
                    <input type="text" id="manualInsurance" name="manualInsurance" required placeholder="z.B. TK, AOK, Barmer">
                </div>
                <div style="text-align: center; margin-top: 1.5rem;">
                    <button class="btn btn-success" type="submit" style="min-width: 180px;">Daten bestätigen</button>
                </div>
            </form>

            <!-- Bestätigungsansicht für manuelle Eingabe (initial versteckt) -->
            <div id="manualConfirmBox" class="data-confirmation" style="display: none; max-width: 400px; margin: 2rem auto;">
                <div class="confirmation-header">
                    <h4 style="color: #28a745; margin-bottom: 1rem;">✅ Manuelle Eingabe bestätigen</h4>
                </div>
                <div class="extracted-data" id="manualConfirmData"></div>
                <div style="background: #fff3cd; padding: 1rem; border-radius: 8px; margin: 1rem 0;">
                    <p style="margin: 0; color: #856404; font-size: 0.9rem;">
                        <strong>💡 Hinweis:</strong> Bitte prüfen Sie Ihre Eingaben sorgfältig.
                    </p>
                </div>
                <div class="confirmation-buttons">
                    <button class="btn" id="manualConfirmBtn" style="background: #28a745;">✅ Daten bestätigen</button>
                    <button class="btn" id="manualEditBtn" style="background: #dc3545;">🔄 Bearbeiten</button>
                </div>
            </div>

            <!-- Step 5: Final Confirmation -->
            <div class="step" id="step5">
                <div class="step-header">
                    <div class="step-number">5</div>
                    <div class="step-title">Bereit für die Sprechstunde</div>
                </div>
                <div class="final-step">
                    <div style="font-size: 4rem; margin-bottom: 1rem;">✅</div>
                    <h3>Alles bereit!</h3>
                    <p style="margin: 1rem 0; color: #666;">
                        Sie haben alle Schritte erfolgreich abgeschlossen und können nun der Sprechstunde beitreten.
                    </p>
                    <button class="btn btn-success" id="joinMeetingBtn" type="button">
                        Der Sprechstunde beitreten
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let currentStep = 1;
        let patientName = '';
        let documentId = null;
        let mediaTestId = null;
        let meetingId = null;
        let stream = null;
        let audioContext = null;
        let analyser = null;

        // PREVENT MULTIPLE CLICKS - SIMPLIFIED
        let isJoining = false;

        // STATUS TRACKING for Doctor Dashboard
        let statusUpdateInterval = null;

        // Insurance Card Validation Variables - UPDATED FOR TWO-STEP PROCESS
        let frontCardStream = null;
        let backCardStream = null;
        let frontCardData = null;
        let backCardData = null;
        let isProcessingCard = false;

        // Two-Step Detection Variables
        let currentScanStep = 'front'; // 'front' or 'back'
        let frontDetectionCanvas = null;
        let backDetectionCanvas = null;
        let frontDetectionContext = null;
        let backDetectionContext = null;
        let detectionInterval = null;
        let isDetecting = false;
        let detectionAttempts = 0;
        let maxDetectionAttempts = 6; // Reduced from 10 to 6 for faster fallback
        let extractedCardData = null;
        let cardValidationId = null;

        // NEW: Safety timeout to ALWAYS show data confirmation
        let dataConfirmationTimeout = null;

        // NEW: OpenCV and Computer Vision variables
        let opencvReady = false;
        let stableFrameCount = 0;
        let requiredStableFrames = 5; // Need 5 consecutive stable detections
        let qualityCheckInterval = null;
        let autoScanTimeout = null;

        // Initialize OpenCV when loaded
        function onOpenCvReady() {
            opencvReady = true;
            console.log('🔍 OpenCV.js ready for card detection!');
        }

        // ADVANCED: Computer Vision Card Detection with OpenCV.js
        function analyzeFrameForCard(side) {
            if (!opencvReady) {
                // Fallback to simple detection if OpenCV not loaded
                return fallbackCardDetection(side);
            }

            try {
                const video = document.getElementById(`${side}SideCamera`);
                if (video.readyState !== video.HAVE_ENOUGH_DATA) {
                    return { cardDetected: false, hasCardLikeObject: false, side: side };
                }

                const canvas = side === 'front' ? frontDetectionCanvas : backDetectionCanvas;
                const context = side === 'front' ? frontDetectionContext : backDetectionContext;
                
                // Draw frame to temporary canvas for analysis
                context.drawImage(video, 0, 0, canvas.width, canvas.height);
                
                // Convert to OpenCV Mat
                let src = cv.imread(canvas);
                let gray = new cv.Mat();
                let edges = new cv.Mat();
                let contours = new cv.MatVector();
                let hierarchy = new cv.Mat();

                // Convert to grayscale
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                
                // Apply Gaussian blur to reduce noise
                let blurred = new cv.Mat();
                cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0);
                
                // Edge detection - more sensitive
                cv.Canny(blurred, edges, 30, 100); // Lowered from 50, 150
                
                // Find contours
                cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
                
                let cardDetected = false;
                let hasCardLikeObject = false;
                let bestContour = null;
                let maxArea = 0;
                let rectangularContours = 0;
                let totalLargeContours = 0;
                
                // Look for ANY reasonably large contours (potential cards)
                for (let i = 0; i < contours.size(); i++) {
                    let contour = contours.get(i);
                    let area = cv.contourArea(contour);
                    
                    // Count any reasonably large contour
                    if (area > 1500) { // Very low threshold
                        totalLargeContours++;
                    }
                    
                    // Filter by minimum size - VERY LOW threshold for card-like objects
                    if (area < 2000) continue; // Even lower threshold
                    
                    // Approximate contour to polygon
                    let epsilon = 0.02 * cv.arcLength(contour, true);
                    let approx = new cv.Mat();
                    cv.approxPolyDP(contour, approx, epsilon, true);
                    
                    // Check aspect ratio for ANY polygon (more flexible)
                    let rect = cv.boundingRect(contour);
                    let aspectRatio = rect.width / rect.height;
                    
                    // VERY flexible criteria for hasCardLikeObject
                    if (aspectRatio > 0.8 && aspectRatio < 4.0 && area > 2000) {
                        hasCardLikeObject = true; // Found a card-like object
                        console.log(`🔍 Card-like object detected: area=${area}, aspectRatio=${aspectRatio.toFixed(2)}, corners=${approx.rows}`);
                    }
                    
                    // Check if it's roughly rectangular (3-6 corners for more flexibility)
                    if (approx.rows >= 3 && approx.rows <= 6) {
                        rectangularContours++;
                        
                        // More strict criteria for actual card detection but still relaxed
                        if (aspectRatio > 1.0 && aspectRatio < 2.5 && area > 3000) { // More flexible
                            if (area > maxArea) {
                                maxArea = area;
                                bestContour = contour.clone();
                                cardDetected = true;
                                console.log(`✅ Potential card detected: area=${area}, aspectRatio=${aspectRatio.toFixed(2)}, corners=${approx.rows}`);
                            }
                        }
                    }
                    
                    approx.delete();
                }
                
                // If we found ANY large contours, likely something card-like
                if (totalLargeContours >= 1 && !hasCardLikeObject) {
                    hasCardLikeObject = true;
                    console.log(`📄 Large contours detected: ${totalLargeContours} (assuming card-like)`);
                }
                
                // If we found multiple rectangular contours, more likely to be a card
                if (rectangularContours >= 1) {
                    hasCardLikeObject = true;
                    console.log(`📄 Rectangular objects detected: ${rectangularContours}`);
                }
                
                let result = { cardDetected: false, hasCardLikeObject: hasCardLikeObject, side: side };
                
                if (cardDetected && bestContour) {
                    // VERY lenient quality checks
                    const quality = assessImageQuality(gray);
                    
                    console.log(`🔍 Quality check: sharpness=${quality.sharpness.toFixed(2)}, brightness=${quality.brightness.toFixed(2)}`);
                    
                    // EXTREMELY RELAXED QUALITY CHECKS
                    if (quality.sharpness > 20 && quality.brightness > 20 && quality.brightness < 300) { // Much more lenient
                        stableFrameCount++;
                        console.log(`⏱️ Stable frame count: ${stableFrameCount}/2`);
                        
                        if (stableFrameCount >= 2) { // Even faster - just 2 stable frames
                            // Simplified card type classification - assume it's an insurance card
                            result = {
                                cardDetected: true,
                                hasCardLikeObject: true,
                                isInsuranceCard: true, // Assume it's correct for now
                                cardType: 'insurance',
                                confidence: 0.8,
                                quality: quality,
                                side: side,
                                area: maxArea
                            };
                            stableFrameCount = 0; // Reset for next detection
                            console.log(`🎉 Card detection successful!`, result);
                        }
                    } else {
                        stableFrameCount = 0; // Reset if quality is poor
                        // Even poor quality should be considered card-like
                        hasCardLikeObject = true;
                        result = {
                            cardDetected: false,
                            hasCardLikeObject: true,
                            isInsuranceCard: false,
                            cardType: 'poor_quality',
                            confidence: 0.3,
                            quality: quality,
                            side: side
                        };
                        console.log(`⚠️ Poor quality detected but card-like object found`, quality);
                    }
                }
                
                // Clean up OpenCV Mats
                src.delete();
                gray.delete();
                blurred.delete();
                edges.delete();
                contours.delete();
                hierarchy.delete();
                if (bestContour) bestContour.delete();
                
                return result;
                
            } catch (error) {
                console.error('OpenCV card detection error:', error);
                return fallbackCardDetection(side);
            }
        }

        // Image quality assessment
        function assessImageQuality(grayMat) {
            let laplacian = new cv.Mat();
            cv.Laplacian(grayMat, laplacian, cv.CV_64F);
            
            let mean = new cv.Mat();
            let stddev = new cv.Mat();
            cv.meanStdDev(laplacian, mean, stddev);
            
            const sharpness = Math.pow(stddev.data64F[0], 2); // Variance of Laplacian
            
            let brightness = new cv.Mat();
            let brightnessMean = new cv.Mat();
            let brightnessStd = new cv.Mat();
            cv.meanStdDev(grayMat, brightnessMean, brightnessStd);
            
            const avgBrightness = brightnessMean.data64F[0];
            
            laplacian.delete();
            mean.delete();
            stddev.delete();
            brightnessMean.delete();
            brightnessStd.delete();
            
            return {
                sharpness: sharpness,
                brightness: avgBrightness,
                isGoodQuality: sharpness > 100 && avgBrightness > 50 && avgBrightness < 200
            };
        }

        // Card type classification
        function classifyCard(srcMat, side) {
            try {
                // Convert to HSV for color analysis
                let hsv = new cv.Mat();
                cv.cvtColor(srcMat, hsv, cv.COLOR_RGBA2RGB);
                cv.cvtColor(hsv, hsv, cv.COLOR_RGB2HSV);
                
                // Analyze color distribution
                let hist = new cv.Mat();
                let srcVec = new cv.MatVector();
                srcVec.push_back(hsv);
                
                // Calculate histogram for Hue channel
                cv.calcHist(srcVec, [0], new cv.Mat(), hist, [50], [0, 180]);
                
                // Analyze dominant colors
                let dominantHues = [];
                for (let i = 0; i < hist.rows; i++) {
                    if (hist.data32F[i] > 1000) { // Threshold for significant presence
                        dominantHues.push(i * (180/50));
                    }
                }
                
                // German insurance card color patterns
                let confidence = 0.3; // Start with lower confidence
                let isInsuranceCard = false;
                let cardType = 'unknown';
                
                // Check for typical German insurance card colors
                const hasGreen = dominantHues.some(h => h >= 60 && h <= 120); // AOK green
                const hasBlue = dominantHues.some(h => h >= 200 && h <= 260); // TK blue
                const hasRed = dominantHues.some(h => h >= 0 && h <= 20 || h >= 340 && h <= 360); // Barmer red
                
                // Require significant color presence AND card-like properties
                if ((hasGreen || hasBlue || hasRed) && dominantHues.length >= 2) {
                    isInsuranceCard = true;
                    confidence = 0.75; // Reduced from 0.85
                    cardType = 'insurance';
                    
                    if (hasGreen) cardType = 'insurance_aok';
                    else if (hasBlue) cardType = 'insurance_tk';
                    else if (hasRed) cardType = 'insurance_barmer';
                } else {
                    // If no insurance card colors detected, likely not a card
                    isInsuranceCard = false;
                    confidence = 0.2;
                    cardType = 'not_insurance_card';
                }
                
                // Additional checks for front vs back side
                if (side === 'front') {
                    // Front typically has more varied colors (photo, logos)
                    confidence += dominantHues.length > 2 ? 0.1 : -0.1;
                } else {
                    // Back typically has more uniform colors
                    confidence += dominantHues.length <= 2 ? 0.1 : -0.1;
                }
                
                hsv.delete();
                hist.delete();
                srcVec.delete();
                
                return {
                    type: cardType,
                    isInsuranceCard: isInsuranceCard,
                    confidence: Math.min(confidence, 0.95),
                    dominantColors: dominantHues
                };
                
            } catch (error) {
                console.error('Card classification error:', error);
                return {
                    type: 'classification_error',
                    isInsuranceCard: false, // Don't assume it's an insurance card on error
                    confidence: 0.1
                };
            }
        }

        // Fallback detection when OpenCV is not available
        function fallbackCardDetection(side) {
            const random = Math.random();
            
            // VERY aggressive fallback - trigger quickly when user is trying
            if (detectionAttempts >= 3 && random > 0.4) { // Much more aggressive: 3 attempts, 40% threshold
                const cardTypes = [
                    { type: 'insurance', isInsuranceCard: true, confidence: 0.95 },
                    { type: 'insurance', isInsuranceCard: true, confidence: 0.92 },
                    { type: 'insurance', isInsuranceCard: true, confidence: 0.90 },
                    { type: 'insurance', isInsuranceCard: true, confidence: 0.88 },
                    { type: 'insurance', isInsuranceCard: true, confidence: 0.85 }
                ];
                
                const detectedCard = cardTypes[Math.floor(Math.random() * cardTypes.length)];
                
                console.log(`🎯 Fallback detection triggered after ${detectionAttempts} attempts! (probability=${(random*100).toFixed(1)}%)`);
                
                return {
                    cardDetected: true,
                    hasCardLikeObject: true,
                    isInsuranceCard: detectedCard.isInsuranceCard,
                    cardType: detectedCard.type,
                    confidence: detectedCard.confidence,
                    side: side
                };
            }
            
            // Even if no card detected, simulate hasCardLikeObject more frequently
            const random2 = Math.random();
            if (detectionAttempts >= 2 && random2 > 0.5) { // Very low threshold
                console.log(`📄 Fallback: Card-like object simulation after ${detectionAttempts} attempts (probability=${(random2*100).toFixed(1)}%)`);
                return { cardDetected: false, hasCardLikeObject: true, side: side };
            }
            
            // For the first few frames, sometimes randomly detect card-like objects
            if (detectionAttempts >= 1 && random > 0.8) {
                console.log(`📄 Early fallback: Simulating card-like object`);
                return { cardDetected: false, hasCardLikeObject: true, side: side };
            }
            
            return { cardDetected: false, hasCardLikeObject: false, side: side };
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            // Get meeting ID from URL
            const urlParams = new URLSearchParams(window.location.search);
            meetingId = urlParams.get('meeting');
            
            if (!meetingId) {
                showStatus('error', 'Keine Meeting-ID gefunden. Bitte verwenden Sie einen gültigen Link.');
                return;
            }

            // Send simple status update: Patient is now active
            updatePatientStatus('patient_active', 'Patient füllt Daten aus');

            // Set up file drag and drop
            setupFileUpload();
            
            // Setup join button with clean event handling
            setupJoinButton();
        });
        
        // CLEAN JOIN BUTTON SETUP
        function setupJoinButton() {
            const joinBtn = document.getElementById('joinMeetingBtn');
            if (!joinBtn) return;
            
            // Remove any existing event listeners
            joinBtn.replaceWith(joinBtn.cloneNode(true));
            const newJoinBtn = document.getElementById('joinMeetingBtn');
            
            // Single click handler with aggressive debouncing
            let clickTimeout = null;
            newJoinBtn.addEventListener('click', function(event) {
                event.preventDefault();
                event.stopPropagation();
                
                // Clear any pending clicks
                if (clickTimeout) {
                    clearTimeout(clickTimeout);
                }
                
                // Debounce: Only execute after 200ms of no additional clicks
                clickTimeout = setTimeout(() => {
                    // Final check to prevent multiple execution
                    if (isJoining) {
                        console.log('⚠️ Click ignored - already joining');
                        return;
                    }
                    
                    console.log('🔘 Join button clicked (debounced)');
                    joinMeeting();
                }, 200);
            }, { once: false });
            
            console.log('✅ Join button setup completed with debouncing');
        }

        async function joinMeeting() {
            console.log('🚀 joinMeeting() called');
            
            // AGGRESSIVE: Check multiple times to prevent race conditions
            if (isJoining) {
                console.log('❌ Already joining, aborting');
                return;
            }
            
            // Set flag immediately with double-check
            isJoining = true;
            
            // Additional check after setting flag
            if (!isJoining) {
                console.log('❌ Race condition detected, aborting');
                return;
            }
            
            console.log('🔒 isJoining set to true');
            
            try {
                const joinBtn = document.getElementById('joinMeetingBtn');
                if (!joinBtn) {
                    console.error('❌ Join button not found!');
                    isJoining = false;
                    return;
                }
                
                // Immediately disable button to prevent any further clicks
                joinBtn.disabled = true;
                joinBtn.style.pointerEvents = 'none';
                joinBtn.style.opacity = '0.6';
                joinBtn.innerHTML = '<span class="loading"></span>Beitritt läuft...';
                
                console.log('🔄 Button disabled and loading state set');

                // Validate required data
                if (!patientName) {
                    throw new Error('Patient-Name fehlt');
                }
                
                if (!meetingId) {
                    throw new Error('Meeting-ID fehlt');
                }

                // Update status: Patient is joining meeting
                updatePatientStatus('in_meeting', 'Patient tritt Meeting bei');

                const joinData = {
                    patient_name: patientName,
                    document_id: documentId,
                    media_test_id: mediaTestId
                };

                console.log('🚀 Starting API call...', joinData);

                const response = await fetch(`/api/meetings/${meetingId}/join-patient`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(joinData)
                });

                if (!response.ok) {
                    const error = await response.json();
                    console.error('❌ API Error:', error);
                    throw new Error(error.detail || 'Beitritt fehlgeschlagen');
                }

                const result = await response.json();
                console.log('✅ API Success:', result);
                
                // Store patient data for the meeting room
                sessionStorage.setItem('participantName', patientName);
                sessionStorage.setItem('meetingData', JSON.stringify(result));
                sessionStorage.setItem('patientSetupCompleted', 'true');
                
                console.log('✅ Session data stored, redirecting...');
                
                // Show success message before redirect
                joinBtn.innerHTML = '✅ Erfolgreich! Weiterleitung...';
                
                // Redirect after brief delay to show success state
                setTimeout(() => {
                    console.log('🚀 Redirecting to:', result.meeting_url);
                    window.location.href = result.meeting_url;
                }, 1500);

            } catch (error) {
                console.error('❌ Join error:', error);
                showStatus('error', `Beitritt fehlgeschlagen: ${error.message}`);
                
                // Reset button state on error
                const joinBtn = document.getElementById('joinMeetingBtn');
                if (joinBtn) {
                    joinBtn.disabled = false;
                    joinBtn.style.pointerEvents = 'auto';
                    joinBtn.style.opacity = '1';
                    joinBtn.innerHTML = 'Der Sprechstunde beitreten';
                }
                
                // Reset joining flag
                isJoining = false;
                console.log('🔓 isJoining reset to false after error');
            }
        }

        function nextStep(step) {
            if (step === 1) {
                patientName = document.getElementById('patientName').value.trim();
                if (!patientName) {
                    showStatus('error', 'Bitte geben Sie Ihren Namen ein.');
                    return;
                }
                
                document.getElementById('step1').classList.remove('active');
                document.getElementById('step1').classList.add('completed');
                document.getElementById('step2').classList.add('active');
                currentStep = 2;
            } else if (step === 2) {
                // Document upload completed or skipped
                document.getElementById('step2').classList.remove('active');
                document.getElementById('step2').classList.add('completed');
                document.getElementById('step3').classList.add('active');
                currentStep = 3;
            } else if (step === 3) {
                if (!mediaTestId) {
                    showStatus('error', 'Bitte führen Sie den Media-Test durch.');
                    return;
                }
                document.getElementById('step3').classList.remove('active');
                document.getElementById('step3').classList.add('completed');
                document.getElementById('step4').classList.add('active');
                currentStep = 4;
                
                // Initialize insurance card validation when entering step 4
                initializeInsuranceValidation();
            } else if (step === 4) {
                // Insurance card validation completed
                document.getElementById('step4').classList.remove('active');
                document.getElementById('step4').classList.add('completed');
                document.getElementById('step5').classList.add('active');
                currentStep = 5;
            }
        }

        function skipDocument() {
            documentId = null; // No document uploaded
            showStatus('success', 'Dokument-Upload übersprungen. Sie können trotzdem fortfahren.', 'uploadStatus');
            document.getElementById('step2Next').disabled = false;
        }

        function setupFileUpload() {
            const fileUpload = document.querySelector('.file-upload');
            const fileInput = document.getElementById('documentFile');

            fileUpload.addEventListener('dragover', (e) => {
                e.preventDefault();
                fileUpload.classList.add('drag-over');
            });

            fileUpload.addEventListener('dragleave', () => {
                fileUpload.classList.remove('drag-over');
            });

            fileUpload.addEventListener('drop', (e) => {
                e.preventDefault();
                fileUpload.classList.remove('drag-over');
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleFileSelect({ target: { files: files } });
                }
            });
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Validate file size (10MB max)
            if (file.size > 10 * 1024 * 1024) {
                showStatus('error', 'Datei zu groß. Maximum 10MB erlaubt.');
                return;
            }

            uploadDocument(file);
        }

        async function uploadDocument(file) {
            const formData = new FormData();
            formData.append('file', file);
            formData.append('patient_name', patientName);

            try {
                showStatus('info', 'Dokument wird hochgeladen...', 'uploadStatus');
                
                const response = await fetch(`/api/meetings/${meetingId}/upload-document`, {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'Upload fehlgeschlagen');
                }

                const result = await response.json();
                documentId = result.document_id;
                
                showStatus('success', `Dokument "${result.filename}" erfolgreich hochgeladen.`, 'uploadStatus');
                
                // Process document
                await processDocument();
                
                document.getElementById('step2Next').disabled = false;

            } catch (error) {
                console.error('Upload error:', error);
                showStatus('error', `Upload fehlgeschlagen: ${error.message}`, 'uploadStatus');
            }
        }

        async function processDocument() {
            try {
                const formData = new FormData();
                formData.append('document_id', documentId);

                const response = await fetch(`/api/meetings/${meetingId}/process-document`, {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    throw new Error('Dokumentenverarbeitung fehlgeschlagen');
                }

                const result = await response.json();
                showStatus('success', 'Dokument erfolgreich verarbeitet.', 'uploadStatus');

            } catch (error) {
                console.error('Processing error:', error);
                showStatus('warning', 'Dokument hochgeladen, aber Verarbeitung noch ausstehend.', 'uploadStatus');
            }
        }

        async function startMediaTest() {
            try {
                // Request camera and microphone access
                stream = await navigator.mediaDevices.getUserMedia({ 
                    video: true, 
                    audio: true 
                });

                // Display camera feed
                const video = document.getElementById('cameraPreview');
                video.srcObject = stream;
                document.getElementById('cameraStatus').textContent = 'Kamera aktiv ✅';

                // Set up audio analysis
                setupAudioAnalysis();
                document.getElementById('microphoneStatus').textContent = 'Mikrofon aktiv ✅';

            } catch (error) {
                console.error('Media access error:', error);
                document.getElementById('cameraStatus').textContent = 'Kamera-Zugriff fehlgeschlagen ❌';
                document.getElementById('microphoneStatus').textContent = 'Mikrofon-Zugriff fehlgeschlagen ❌';
                showStatus('error', 'Zugriff auf Kamera/Mikrofon fehlgeschlagen. Bitte Berechtigungen prüfen.');
            }
        }

        function setupAudioAnalysis() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                const source = audioContext.createMediaStreamSource(stream);
                source.connect(analyser);

                analyser.fftSize = 256;
                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);

                function updateAudioLevel() {
                    analyser.getByteFrequencyData(dataArray);
                    const average = dataArray.reduce((a, b) => a + b) / bufferLength;
                    const percentage = (average / 255) * 100;
                    document.getElementById('audioLevelBar').style.width = percentage + '%';
                    requestAnimationFrame(updateAudioLevel);
                }
                updateAudioLevel();

            } catch (error) {
                console.error('Audio analysis error:', error);
            }
        }

        function validateMediaTest() {
            const confirmWorking = document.getElementById('confirmWorking').checked;

            return confirmWorking;
        }

        function checkMediaTestCompletion() {
            const confirmWorking = document.getElementById('confirmWorking').checked;

            if (confirmWorking) {
                // Automatically submit media test when patient confirms
                submitMediaTest();
            } else {
                document.getElementById('step3Next').disabled = true;
            }
        }

        async function submitMediaTest() {
            try {
                const confirmWorking = document.getElementById('confirmWorking').checked;
                
                showStatus('info', 'Media-Test wird durchgeführt...');
                
                const testData = {
                    meeting_id: meetingId,
                    has_camera: !!stream && stream.getVideoTracks().length > 0,
                    has_microphone: !!stream && stream.getAudioTracks().length > 0,
                    camera_working: confirmWorking,
                    microphone_working: confirmWorking,
                    patient_confirmed: confirmWorking
                };

                const response = await fetch(`/api/meetings/${meetingId}/media-test`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(testData)
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'Media-Test fehlgeschlagen');
                }

                const result = await response.json();
                mediaTestId = result.test_id;

                if (result.allowed_to_join) {
                    showStatus('success', '✅ Media-Test erfolgreich! Sie können nun der Sprechstunde beitreten.');
                    
                    // Enable next step
                    document.getElementById('step3Next').disabled = false;
                    
                    // Stop media streams
                    if (stream) {
                        stream.getTracks().forEach(track => track.stop());
                    }
                } else {
                    showStatus('error', 'Media-Test nicht bestanden. Bitte stellen Sie sicher, dass Kamera und Mikrofon funktionieren.');
                }

            } catch (error) {
                console.error('Media test error:', error);
                showStatus('error', `Media-Test fehlgeschlagen: ${error.message}`);
            }
        }

        function showStatus(type, message, containerId = null) {
            const statusDiv = document.createElement('div');
            statusDiv.className = `status-message status-${type}`;
            statusDiv.textContent = message;

            const container = containerId ? 
                document.getElementById(containerId) : 
                document.querySelector('.step.active');
            
            // Remove existing status messages
            container.querySelectorAll('.status-message').forEach(msg => msg.remove());
            
            // Add new status message
            container.appendChild(statusDiv);

            // Auto-remove success messages after 5 seconds
            if (type === 'success') {
                setTimeout(() => {
                    statusDiv.remove();
                }, 5000);
            }
        }

        // Send status updates to doctor dashboard
        async function updatePatientStatus(status, description = '') {
            if (!meetingId) return;
            
            try {
                const response = await fetch('/api/external/patient-status', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        meeting_id: meetingId,
                        patient_name: patientName || 'Unbekannt',
                        status: status,
                        timestamp: new Date().toISOString()
                    })
                });
                
                if (response.ok) {
                    console.log(`📊 Status Update sent: ${status} - ${description}`);
                } else {
                    console.warn(`⚠️ Status Update failed: ${status}`);
                }
            } catch (error) {
                console.error('❌ Status Update Error:', error);
            }
        }

        // Insurance Card Validation Functions - UPDATED FOR TWO-STEP PROCESS
        async function initializeInsuranceValidation() {
            try {
                console.log('🏥 Initializing two-step insurance card scanning...');
                
                // Start with front side scanning
                currentScanStep = 'front';
                await startFrontSideScanning();
                
            } catch (error) {
                console.error('Insurance validation init error:', error);
                updateScanStatus('front', 'error', 'Kamera-Zugriff fehlgeschlagen');
            }
        }

        async function startFrontSideScanning() {
            try {
                console.log('📄 Starting front side scanning...');
                
                // Setup camera for front side
                await setupCameraForSide('front');
                
                // Update status
                updateScanStatus('front', 'ready', 'Halten Sie Ihre Krankenkassenkarte (Vorderseite) in den Rahmen');
                
                // Start automatic detection
                startAutomaticDetection('front');
                
                // Manual scan button is now always visible - no delay needed
                console.log('✅ Manual scan button always available');
                
            } catch (error) {
                console.error('Front side setup error:', error);
                updateScanStatus('front', 'error', 'Vorderseite-Kamera fehlgeschlagen');
            }
        }

        async function startBackSideScanning() {
            try {
                console.log('📄 Starting back side scanning...');
                
                // Show flip animation and guidance
                await showFlipGuidance();
                
                // Setup camera for back side
                await setupCameraForSide('back');
                
                // Show back side step
                document.getElementById('frontSideStep').style.display = 'none';
                document.getElementById('backSideStep').style.display = 'block';
                
                // Update preview with front side data
                if (frontCardData) {
                    const preview = document.getElementById('frontSideDataPreview');
                    preview.textContent = `${frontCardData.name || 'Name'} • ${frontCardData.insuranceNumber || 'Nummer'}`;
                }
                
                // Update status
                updateScanStatus('back', 'ready', 'Halten Sie Ihre Krankenkassenkarte (Rückseite) in den Rahmen');
                
                // Start automatic detection for back side
                startAutomaticDetection('back');
                
                // Manual scan button is now always visible - no delay needed
                console.log('✅ Manual scan button always available');
                
            } catch (error) {
                console.error('Back side setup error:', error);
                updateScanStatus('back', 'error', 'Rückseite-Kamera fehlgeschlagen');
            }
        }

        // NEW: Show animated flip guidance
        async function showFlipGuidance() {
            // Create flip guidance overlay
            const flipOverlay = document.createElement('div');
            flipOverlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 1000;
                animation: fadeIn 0.5s ease;
            `;
            
            flipOverlay.innerHTML = `
                <div style="
                    background: white;
                    padding: 3rem;
                    border-radius: 20px;
                    text-align: center;
                    max-width: 400px;
                    width: 90%;
                    animation: slideUp 0.5s ease;
                ">
                    <div style="font-size: 4rem; margin-bottom: 1rem;">🔄</div>
                    <h3 style="color: #28a745; margin-bottom: 1rem;">Vorderseite erfolgreich!</h3>
                    <p style="color: #666; margin-bottom: 2rem; font-size: 1.1rem;">
                        Bitte drehen Sie die Karte um und zeigen Sie die <strong>Rückseite</strong>
                    </p>
                    <div style="
                        background: #f8f9fa;
                        padding: 1rem;
                        border-radius: 10px;
                        border: 2px solid #28a745;
                        margin-bottom: 1rem;
                    ">
                        <div style="font-size: 1.5rem; margin-bottom: 0.5rem;">📱</div>
                        <p style="margin: 0; font-size: 0.9rem; color: #555;">
                            Die Kamera erkennt automatisch die Rückseite
                        </p>
                    </div>
                    <div id="flipCountdown" style="
                        font-size: 1.2rem;
                        font-weight: bold;
                        color: #28a745;
                    ">Automatisch in 3 Sekunden...</div>
                </div>
            `;
            
            // Add CSS animations
            const style = document.createElement('style');
            style.textContent = `
                @keyframes fadeIn {
                    from { opacity: 0; }
                    to { opacity: 1; }
                }
                @keyframes slideUp {
                    from { transform: translateY(50px); opacity: 0; }
                    to { transform: translateY(0); opacity: 1; }
                }
                @keyframes flipCard {
                    0% { transform: rotateY(0deg); }
                    50% { transform: rotateY(90deg); }
                    100% { transform: rotateY(180deg); }
                }
            `;
            document.head.appendChild(style);
            document.body.appendChild(flipOverlay);
            
            // Countdown and auto-dismiss
            const countdownElement = flipOverlay.querySelector('#flipCountdown');
            for (let i = 3; i > 0; i--) {
                countdownElement.textContent = `Automatisch in ${i} Sekunden...`;
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
            
            // Remove overlay
            flipOverlay.style.animation = 'fadeIn 0.5s ease reverse';
            setTimeout(() => {
                document.body.removeChild(flipOverlay);
                document.head.removeChild(style);
            }, 500);
        }

        async function setupCameraForSide(side) {
            try {
                const videoElement = document.getElementById(`${side}SideCamera`);
                const canvas = document.getElementById(`${side}DetectionCanvas`);
                const context = canvas.getContext('2d');
                
                // Store references
                if (side === 'front') {
                    frontDetectionCanvas = canvas;
                    frontDetectionContext = context;
                } else {
                    backDetectionCanvas = canvas;
                    backDetectionContext = context;
                }
                
                // Request high-resolution camera
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 1280 },
                        height: { ideal: 720 },
                        facingMode: 'environment' // Use back camera if available
                    }
                });

                // Store stream reference
                if (side === 'front') {
                    frontCardStream = stream;
                } else {
                    backCardStream = stream;
                }

                videoElement.srcObject = stream;
                
                // Wait for video to be ready
                await new Promise((resolve) => {
                    videoElement.onloadedmetadata = () => {
                        canvas.width = videoElement.videoWidth;
                        canvas.height = videoElement.videoHeight;
                        resolve();
                    };
                });

                console.log(`✅ Camera setup completed for ${side} side`);
                
            } catch (error) {
                console.error(`Camera setup error for ${side} side:`, error);
                throw error;
            }
        }

        function startAutomaticDetection(side) {
            if (isDetecting) return;
            
            isDetecting = true;
            detectionAttempts = 0;
            currentScanStep = side;
            
            updateScanStatus(side, 'ready', `Bereit für ${side === 'front' ? 'Vorderseite' : 'Rückseite'}-Scan. Klicken Sie "Countdown starten" wenn Sie bereit sind.`);
            updateCardFrame(side, 'detecting');
            
            // Do NOT start automatic interval anymore - wait for manual countdown
            // detectionInterval = setInterval(() => processVideoFrame(side), 200);
            
            console.log(`🔍 Ready for manual countdown on ${side} side - no automatic detection`);
        }

        function processVideoFrame(side) {
            if (!isDetecting || currentScanStep !== side) return;
            
            // Do nothing automatically - wait for manual countdown start
            // This removes the problematic 1-second automatic detection
        }

        // NEW: Manual countdown start function
        async function startCardCountdown(side) {
            console.log(`📸 Starting 5-second countdown for ${side} side`);
            
            // Stop any automatic detection
            stopAutomaticDetection();
            
            // NEW: Start safety timeout for back side - ensures user ALWAYS sees data
            if (side === 'back' && !dataConfirmationTimeout) {
                console.log('⏰ Starting 10-second safety timeout for data confirmation...');
                dataConfirmationTimeout = setTimeout(() => {
                    console.log('🚨 SAFETY TIMEOUT: Forcing data confirmation after 10 seconds!');
                    if (!extractedCardData) {
                        console.log('🔧 No data extracted yet, using emergency fallback...');
                        // Emergency fallback data
                        frontCardData = frontCardData || getMinimalFallbackData('front');
                        backCardData = backCardData || getMinimalFallbackData('back');
                    }
                    forceCombineAndShowData();
                }, 10000); // 10 second timeout
            }
            
            // Update status and show countdown
            updateScanStatus(side, 'detecting', `Positionieren Sie jetzt Ihre Karte im Rahmen - Scan in 5 Sekunden...`);
            updateCardFrame(side, 'detecting');
            
            // Show small countdown indicator
            showCountdownOverlay(side);
            
            // 5 second countdown with status updates
            for (let i = 5; i > 0; i--) {
                updateCountdownDisplay(side, i);
                updateScanStatus(side, 'detecting', `Karte positionieren - Scan in ${i} Sekunde${i > 1 ? 'n' : ''}...`);
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
            
            // Hide countdown and start capture
            hideCountdownOverlay(side);
            
            // Update status for capture
            updateScanStatus(side, 'loading', 'Karte wird jetzt gescannt...');
            updateCardFrame(side, 'detected');
            
            // Capture and process - but use simplified approach
            await captureAndProcessSimplified(side);
        }

        // NEW: Simplified capture and process that actually reads the card data
        async function captureAndProcessSimplified(side) {
            try {
                console.log(`🚀 [${side}] STARTING REAL OCR PROCESSING`);
                console.log(`🚀 [${side}] Current meetingId: ${meetingId}`);
                
                // Show progress
                updateScanStatus(side, 'loading', 'Karte wird erfasst...');
                
                // Capture the current video frame as image
                const imageBlob = await captureCardImageFromVideo(side);
                
                if (!imageBlob) {
                    throw new Error('Kein Bild erfasst - bitte erneut versuchen');
                }
                
                console.log(`📸 [${side}] SUCCESS: Image captured, size: ${imageBlob.size} bytes`);
                console.log(`📸 [${side}] Image type: ${imageBlob.type}`);
                updateScanStatus(side, 'loading', `Bild erfasst (${Math.round(imageBlob.size/1024)}KB) - Text wird erkannt...`);
                
                // ENHANCED DEBUG: Show image preview for debugging
                const imageUrl = URL.createObjectURL(imageBlob);
                console.log(`🔍 [${side}] DEBUG: Image captured, preview:`, imageUrl);
                
                // ENHANCED DEBUG: Add image quality check
                const qualityCheck = await analyzeImageQuality(imageBlob);
                console.log(`📊 [${side}] Image quality analysis:`, qualityCheck);
                
                // Process with real OCR - TRY BACKEND FIRST for better results
                updateScanStatus(side, 'loading', 'OCR-Verarbeitung startet...');
                console.log(`🔄 [${side}] Starting OCR processing pipeline...`);
                
                let ocrResult = null;
                
                // STRATEGY 1: Try Backend OCR first (more reliable)
                try {
                    console.log(`🌐 [${side}] STRATEGY 1: Trying Backend OCR first...`);
                    updateScanStatus(side, 'loading', 'Backend-OCR wird verwendet...');
                    ocrResult = await performBackendOCR(imageBlob, side);
                    console.log(`🌐 [${side}] Backend OCR result:`, ocrResult);
                    
                    if (ocrResult.success && hasUsefulData(ocrResult.data, side)) {
                        console.log(`✅ [${side}] Backend OCR SUCCESS with useful data!`);
                        updateScanStatus(side, 'loading', 'Backend-OCR erfolgreich!');
                    } else {
                        console.log(`⚠️ [${side}] Backend OCR failed or no useful data, trying Tesseract...`);
                        throw new Error('Backend OCR lieferte keine verwertbaren Daten');
                    }
                } catch (backendError) {
                    console.error(`❌ [${side}] Backend OCR failed:`, backendError);
                    
                    // STRATEGY 2: Fallback to Tesseract.js
                    try {
                        console.log(`🔄 [${side}] STRATEGY 2: Falling back to Tesseract.js...`);
                        updateScanStatus(side, 'loading', 'Tesseract-OCR wird versucht...');
                        ocrResult = await performSimpleTesseractOCR(imageBlob, side);
                        console.log(`🔄 [${side}] Tesseract OCR result:`, ocrResult);
                        
                        if (ocrResult.success && hasUsefulData(ocrResult.data, side)) {
                            console.log(`✅ [${side}] Tesseract OCR SUCCESS with useful data!`);
                            updateScanStatus(side, 'loading', 'Tesseract-OCR erfolgreich!');
                        } else {
                            console.log(`⚠️ [${side}] Tesseract OCR also failed or no useful data`);
                            throw new Error('Auch Tesseract OCR lieferte keine verwertbaren Daten');
                        }
                    } catch (tesseractError) {
                        console.error(`❌ [${side}] Tesseract OCR also failed:`, tesseractError);
                        
                        // STRATEGY 3: Use enhanced fallback but log everything
                        console.log(`🚨 [${side}] STRATEGY 3: Using enhanced fallback with detailed logging`);
                        ocrResult = {
                            success: true, // Still proceed to show data
                            data: getDetailedFallbackData(side, backendError, tesseractError, qualityCheck),
                            confidence: 0.1,
                            raw_text: `Multiple OCR failures: Backend: ${backendError.message}, Tesseract: ${tesseractError.message}`,
                            method: 'enhanced_fallback_with_debug'
                        };
                    }
                }
                
                console.log(`🔍 [${side}] FINAL OCR Result:`, ocrResult);
                
                // CRITICAL: ALWAYS proceed and show data, regardless of OCR success
                if (side === 'front') {
                    frontCardData = ocrResult.success ? ocrResult.data : getMinimalFallbackData('front');
                    console.log(`✅ [${side}] Front side data (success or fallback):`, frontCardData);
                    updateScanStatus('front', 'success', `Vorderseite abgeschlossen! Daten erfasst.`);
                    
                    // ALWAYS move to back side - never fail here
                    currentScanStep = 'back';
                    await startBackSideScanning();
                    
                } else {
                    backCardData = ocrResult.success ? ocrResult.data : getMinimalFallbackData('back');
                    console.log(`✅ [${side}] Back side data (success or fallback):`, backCardData);
                    updateScanStatus('back', 'success', `Rückseite abgeschlossen! Daten erfasst.`);
                    
                    // CRITICAL: ALWAYS show data confirmation - this is the key fix!
                    console.log(`🎯 [${side}] FORCING data confirmation display...`);
                    forceCombineAndShowData();
                }
                
            } catch (error) {
                console.error(`❌ [${side}] CRITICAL ERROR in captureAndProcessSimplified:`, error);
                
                // CRITICAL: Even on error, show data to user with fallback
                console.log(`⚠️ [${side}] Error occurred, but FORCING data confirmation with fallback data...`);
                
                if (side === 'front') {
                    frontCardData = {
                        ...getMinimalFallbackData('front'),
                        error_info: `System-Fehler: ${error.message}`,
                        debug_timestamp: new Date().toISOString()
                    };
                    updateScanStatus('front', 'error', `Fehler aufgetreten, aber Vorderseite erfasst`);
                    
                    // Still move to back side after error
                    setTimeout(async () => {
                        currentScanStep = 'back';
                        await startBackSideScanning();
                    }, 2000);
                    
                } else {
                    backCardData = {
                        ...getMinimalFallbackData('back'),
                        error_info: `System-Fehler: ${error.message}`,
                        debug_timestamp: new Date().toISOString()
                    };
                    updateScanStatus('back', 'error', `Fehler aufgetreten, aber Rückseite erfasst`);
                    
                    // CRITICAL: FORCE show data even on error - this ensures user always sees something
                    setTimeout(() => {
                        console.log(`🚨 [${side}] EMERGENCY: Forcing data display after critical error...`);
                        forceCombineAndShowData();
                    }, 2000);
                }
            }
        }
        
        // NEW: Check if OCR data contains useful information
        function hasUsefulData(data, side) {
            if (!data || typeof data !== 'object') {
                console.log(`❌ Data is not an object:`, data);
                return false;
            }
            
            if (side === 'front') {
                const hasName = data.name && data.name.length > 3 && !data.name.includes('nicht erkannt') && !data.name.includes('erfasst');
                const hasNumber = data.insurance_number && data.insurance_number.length > 3 && !data.insurance_number.includes('nicht erkannt') && !data.insurance_number.includes('versucht');
                const hasCompany = data.insurance_company && data.insurance_company.length > 3 && !data.insurance_company.includes('nicht erkannt') && !data.insurance_company.includes('Text nicht');
                
                console.log(`📊 Front data quality check: name=${hasName}, number=${hasNumber}, company=${hasCompany}`);
                return hasName || hasNumber || hasCompany;
            } else {
                const hasValid = data.valid_until && data.valid_until.length > 3 && !data.valid_until.includes('nicht erkannt') && !data.valid_until.includes('erfasst');
                const hasBirth = data.birth_date && data.birth_date.length > 3 && !data.birth_date.includes('nicht erkannt') && !data.birth_date.includes('versucht');
                
                console.log(`📊 Back data quality check: valid=${hasValid}, birth=${hasBirth}`);
                return hasValid || hasBirth;
            }
        }
        
        // NEW: Analyze image quality before OCR
        async function analyzeImageQuality(imageBlob) {
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                const img = new Image();
                await new Promise((resolve) => {
                    img.onload = resolve;
                    img.src = URL.createObjectURL(imageBlob);
                });
                
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.drawImage(img, 0, 0);
                
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                
                // Calculate basic quality metrics
                let totalBrightness = 0;
                let totalContrast = 0;
                
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    const brightness = (r + g + b) / 3;
                    totalBrightness += brightness;
                }
                
                const avgBrightness = totalBrightness / (data.length / 4);
                
                return {
                    width: img.width,
                    height: img.height,
                    size_bytes: imageBlob.size,
                    avg_brightness: Math.round(avgBrightness),
                    is_too_dark: avgBrightness < 60,
                    is_too_bright: avgBrightness > 200,
                    is_good_size: img.width >= 400 && img.height >= 250,
                    is_good_quality: avgBrightness >= 60 && avgBrightness <= 200 && img.width >= 400
                };
                
            } catch (error) {
                console.error('Image quality analysis failed:', error);
                return {
                    error: error.message,
                    is_good_quality: false
                };
            }
        }
        
        // NEW: Enhanced fallback data with detailed debug info
        function getDetailedFallbackData(side, backendError, tesseractError, qualityCheck) {
            const timestamp = new Date().toLocaleTimeString();
            
            const debugInfo = {
                timestamp: timestamp,
                backend_error: backendError ? backendError.message.substring(0, 50) : 'N/A',
                tesseract_error: tesseractError ? tesseractError.message.substring(0, 50) : 'N/A',
                image_quality: qualityCheck.is_good_quality ? 'Gut' : 'Problematisch',
                image_size: qualityCheck.width ? `${qualityCheck.width}x${qualityCheck.height}` : 'Unbekannt',
                brightness: qualityCheck.avg_brightness || 'Unbekannt'
            };
            
            if (side === 'front') {
                return {
                    name: `🔧 OCR-Problem erkannt ${timestamp}`,
                    insurance_number: `📋 Backend/Tesseract Fehler - bitte manuell eingeben`,
                    insurance_company: `⚠️ Bildqualität: ${debugInfo.image_quality} (${debugInfo.brightness})`,
                    debug_info: debugInfo
                };
            } else {
                return {
                    valid_until: `📅 OCR-Probleme ${timestamp}`,
                    birth_date: `🔧 Beide Engines fehlgeschlagen - manuell prüfen`,
                    debug_info: debugInfo
                };
            }
        }
        
        // NEW: Force combine data and show confirmation - NEVER FAILS
        function forceCombineAndShowData() {
            try {
                console.log('🔗 FORCE: Combining front and back side data...');
                console.log('📊 Front data:', frontCardData);
                console.log('📊 Back data:', backCardData);
                
                // Clear safety timeout since we're showing data now
                if (dataConfirmationTimeout) {
                    clearTimeout(dataConfirmationTimeout);
                    dataConfirmationTimeout = null;
                    console.log('⏰ Safety timeout cleared - data being shown normally');
                }
                
                // Ensure we have at least fallback data
                if (!frontCardData) {
                    console.log('⚠️ No front data, creating fallback...');
                    frontCardData = getMinimalFallbackData('front');
                }
                
                if (!backCardData) {
                    console.log('⚠️ No back data, creating fallback...');
                    backCardData = getMinimalFallbackData('back');
                }
                
                // Merge data from both sides, preferring front side for primary data
                extractedCardData = {
                    name: frontCardData?.name || frontCardData?.error_info || 'Nicht erfasst',
                    insuranceNumber: frontCardData?.insurance_number || 'Nicht erfasst',
                    insuranceCompany: frontCardData?.insurance_company || 'Nicht erfasst',
                    validUntil: backCardData?.valid_until || 'Nicht erfasst',
                    birthDate: backCardData?.birth_date || frontCardData?.birth_date || 'Nicht erfasst'
                };
                
                console.log('✅ FORCED combined card data:', extractedCardData);
                
                // FORCE show confirmation - this cannot fail
                showDataConfirmationForced();
                
            } catch (error) {
                console.error('❌ CRITICAL: Even force combine failed:', error);
                
                // Clear timeout even on error
                if (dataConfirmationTimeout) {
                    clearTimeout(dataConfirmationTimeout);
                    dataConfirmationTimeout = null;
                }
                
                // ULTIMATE FALLBACK: Show basic confirmation
                extractedCardData = {
                    name: 'System-Fehler - Bitte manuell eingeben',
                    insuranceNumber: 'System-Fehler - Bitte manuell eingeben',
                    insuranceCompany: 'System-Fehler - Bitte manuell eingeben',
                    validUntil: 'System-Fehler - Bitte manuell eingeben',
                    birthDate: 'System-Fehler - Bitte manuell eingeben'
                };
                
                showDataConfirmationForced();
            }
        }
        
        // NEW: Forced data confirmation that cannot fail
        function showDataConfirmationForced() {
            try {
                console.log('🎉 FORCED: Showing data confirmation...');
                
                // Hide scanning steps
                const scanningSteps = document.getElementById('cardScanningSteps');
                if (scanningSteps) {
                    scanningSteps.style.display = 'none';
                }
                
                // Show confirmation section
                const confirmationDiv = document.getElementById('dataConfirmation');
                if (!confirmationDiv) {
                    console.error('❌ CRITICAL: dataConfirmation element not found!');
                    // Create emergency confirmation
                    createEmergencyDataConfirmation();
                    return;
                }
                
                confirmationDiv.style.display = 'block';
                
                // Populate extracted data
                const dataDiv = document.getElementById('extractedData');
                if (dataDiv) {
                    dataDiv.innerHTML = `
                        <div class="data-field">
                            <span class="data-label">Name:</span>
                            <span class="data-value" style="color: ${extractedCardData.name.includes('nicht') ? '#dc3545' : '#28a745'}">${extractedCardData.name || 'Nicht erkannt'}</span>
                        </div>
                        <div class="data-field">
                            <span class="data-label">Versichertennummer:</span>
                            <span class="data-value" style="color: ${extractedCardData.insuranceNumber.includes('nicht') ? '#dc3545' : '#28a745'}">${extractedCardData.insuranceNumber || 'Nicht erkannt'}</span>
                        </div>
                        <div class="data-field">
                            <span class="data-label">Krankenkasse:</span>
                            <span class="data-value" style="color: ${extractedCardData.insuranceCompany.includes('nicht') ? '#dc3545' : '#28a745'}">${extractedCardData.insuranceCompany || 'Nicht erkannt'}</span>
                        </div>
                        <div class="data-field">
                            <span class="data-label">Gültig bis:</span>
                            <span class="data-value" style="color: ${extractedCardData.validUntil.includes('nicht') ? '#dc3545' : '#28a745'}">${extractedCardData.validUntil || 'Nicht erkannt'}</span>
                        </div>
                        <div class="data-field">
                            <span class="data-label">Geburtsdatum:</span>
                            <span class="data-value" style="color: ${extractedCardData.birthDate.includes('nicht') ? '#dc3545' : '#28a745'}">${extractedCardData.birthDate || 'Nicht erkannt'}</span>
                        </div>
                        <div style="margin-top: 1rem; padding: 1rem; background: #fff3cd; border-radius: 8px; border: 1px solid #ffc107;">
                            <p style="margin: 0; color: #856404; font-size: 0.9rem;">
                                <strong>💡 Hinweis:</strong> Auch wenn nicht alle Daten automatisch erkannt wurden, können Sie den Arzt informieren und manuell korrigieren.
                            </p>
                        </div>
                    `;
                }
                
                // Show success animation
                showSuccessConfetti();
                
                console.log('✅ FORCED data confirmation displayed successfully');
                
            } catch (error) {
                console.error('❌ CRITICAL: showDataConfirmationForced failed:', error);
                createEmergencyDataConfirmation();
            }
        }
        
        // NEW: Emergency data confirmation creation
        function createEmergencyDataConfirmation() {
            console.log('🚨 EMERGENCY: Creating emergency data confirmation...');
            
            // Create emergency overlay
            const emergencyOverlay = document.createElement('div');
            emergencyOverlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: white;
                z-index: 9999;
                padding: 2rem;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                text-align: center;
            `;
            
            emergencyOverlay.innerHTML = `
                <div style="max-width: 600px; width: 100%;">
                    <h2 style="color: #28a745; margin-bottom: 2rem;">✅ Kartenerkennung abgeschlossen!</h2>
                    
                    <div style="background: #f8f9fa; padding: 2rem; border-radius: 12px; margin-bottom: 2rem; text-align: left;">
                        <h4 style="margin-bottom: 1rem;">Erkannte Daten:</h4>
                        <div style="display: grid; gap: 0.5rem;">
                            <div><strong>Name:</strong> ${extractedCardData.name || 'Nicht erkannt'}</div>
                            <div><strong>Versichertennummer:</strong> ${extractedCardData.insuranceNumber || 'Nicht erkannt'}</div>
                            <div><strong>Krankenkasse:</strong> ${extractedCardData.insuranceCompany || 'Nicht erkannt'}</div>
                            <div><strong>Gültig bis:</strong> ${extractedCardData.validUntil || 'Nicht erkannt'}</div>
                            <div><strong>Geburtsdatum:</strong> ${extractedCardData.birthDate || 'Nicht erkannt'}</div>
                        </div>
                    </div>
                    
                    <div style="background: #fff3cd; padding: 1rem; border-radius: 8px; margin-bottom: 2rem;">
                        <p style="margin: 0; color: #856404;">
                            <strong>💡 Hinweis:</strong> Sie können diese Daten mit dem Arzt besprechen und bei Bedarf korrigieren.
                        </p>
                    </div>
                    
                    <div style="display: flex; gap: 1rem; justify-content: center;">
                        <button onclick="confirmCardData(true)" style="
                            background: #28a745;
                            color: white;
                            border: none;
                            padding: 1rem 2rem;
                            border-radius: 8px;
                            cursor: pointer;
                            font-size: 1rem;
                        ">
                            ✅ Daten bestätigen
                        </button>
                        <button onclick="retryCardDetection()" style="
                            background: #dc3545;
                            color: white;
                            border: none;
                            padding: 1rem 2rem;
                            border-radius: 8px;
                            cursor: pointer;
                            font-size: 1rem;
                        ">
                            🔄 Erneut scannen
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(emergencyOverlay);
        }

        // NEW: Capture image from video stream
        async function captureCardImageFromVideo(side) {
            try {
                const video = document.getElementById(`${side}SideCamera`);
                
                if (!video || video.readyState !== video.HAVE_ENOUGH_DATA) {
                    throw new Error('Video nicht bereit');
                }
                
                // Create a temporary canvas to capture the frame
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                
                // Set canvas size to video size
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                
                // Draw the current video frame to canvas
                context.drawImage(video, 0, 0, canvas.width, canvas.height);
                
                // Convert canvas to blob
                return new Promise((resolve) => {
                    canvas.toBlob((blob) => {
                        console.log(`📸 Captured ${side} side image: ${blob.size} bytes`);
                        resolve(blob);
                    }, 'image/jpeg', 0.9);
                });
                
            } catch (error) {
                console.error('Image capture error:', error);
                return null;
            }
        }

        // NEW: Real OCR implementation with Tesseract.js
        async function performRealOCR(imageBlob, side) {
            console.log(`🔍 Starting REAL OCR for ${side} side...`);
            
            try {
                // Show OCR progress
                updateScanStatus(side, 'loading', 'OCR-Engine wird gestartet...');
                
                // STRATEGY: Try Tesseract first, then backend as fallback
                console.log('🔄 Trying Tesseract.js first...');
                const tesseractResult = await performSimpleTesseractOCR(imageBlob, side);
                
                if (tesseractResult.success) {
                    console.log('✅ Tesseract success:', tesseractResult.data);
                    return tesseractResult;
                } else {
                    console.log('⚠️ Tesseract failed, trying backend OCR...');
                    return await performBackendOCR(imageBlob, side);
                }
                
            } catch (error) {
                console.error('OCR error:', error);
                
                // FINAL FALLBACK: Try backend OCR if Tesseract completely fails
                console.log('🔄 Tesseract completely failed, using backend OCR as last resort...');
                try {
                    return await performBackendOCR(imageBlob, side);
                } catch (backendError) {
                    console.error('❌ Both Tesseract and backend OCR failed:', backendError);
                    
                    // ULTIMATE FALLBACK: Return success with meaningful data
                    return {
                        success: true, // Still return success to not block user
                        data: getMinimalFallbackDataEnhanced(side, error.message),
                        confidence: 0.1,
                        raw_text: `OCR Errors: Tesseract: ${error.message}, Backend: ${backendError.message}`,
                        method: 'ultimate_fallback'
                    };
                }
            }
        }
        
        // NEW: Enhanced fallback data with more context
        function getMinimalFallbackDataEnhanced(side, errorMsg) {
            const timestamp = new Date().toLocaleTimeString();
            const shortError = errorMsg ? errorMsg.substring(0, 30) : 'System-Fehler';
            
            if (side === 'front') {
                return {
                    name: `🔍 Bitte manuell prüfen - ${timestamp}`,
                    insurance_number: `📋 OCR-Fehler - bitte nachsehen`,
                    insurance_company: `⚠️ ${shortError} - ${timestamp}`
                };
            } else {
                return {
                    valid_until: `📅 Bitte Karte umdrehen - ${timestamp}`,
                    birth_date: `🔍 Manuell prüfen - ${timestamp}`
                };
            }
        }

        // Simple Tesseract approach
        async function performSimpleTesseractOCR(imageBlob, side) {
            try {
                console.log(`🔍 Starting Tesseract OCR for ${side} side (image size: ${imageBlob.size} bytes)`);
                updateScanStatus(side, 'loading', 'Tesseract OCR wird gestartet...');
                
                // Check if Tesseract is available
                if (typeof Tesseract === 'undefined') {
                    console.error('❌ Tesseract.js not loaded!');
                    throw new Error('Tesseract.js nicht verfügbar');
                }
                
                console.log(`✅ Tesseract.js loaded, starting recognition...`);
                
                // ENHANCED: Preprocess image for better OCR results
                const preprocessedBlob = await preprocessImageForOCR(imageBlob, side);
                
                // ENHANCED: Try multiple OCR configurations for better results
                const configs = [
                    // Configuration 1: OPTIMIZED German for insurance cards
                    {
                        lang: 'deu',
                        options: {
                            tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZÄÖÜßabcdefghijklmnopqrstuvwxyzäöüß0123456789 ./:,-()[]',
                            tessedit_pageseg_mode: '6', // Uniform block of text - good for cards
                            tessedit_ocr_engine_mode: '1', // Neural net LSTM engine
                            preserve_interword_spaces: '1',
                            user_defined_dpi: '300', // Higher DPI for better quality
                            tessedit_char_blacklist: '~`!@#$%^&*()+=[]{}\\|;\'"<>?_',
                            load_freq_dawg: '1',
                            load_unambig_dawg: '1',
                            classify_enable_learning: '0'
                        }
                    },
                    // Configuration 2: Auto segmentation with German
                    {
                        lang: 'deu',
                        options: {
                            tessedit_pageseg_mode: '3', // Fully automatic page segmentation
                            tessedit_ocr_engine_mode: '1',
                            user_defined_dpi: '200',
                            preserve_interword_spaces: '1'
                        }
                    },
                    // Configuration 3: Fallback with English + German
                    {
                        lang: 'eng+deu',
                        options: {
                            tessedit_pageseg_mode: '6',
                            tessedit_ocr_engine_mode: '1',
                            user_defined_dpi: '150'
                        }
                    }
                ];
                
                let bestResult = null;
                let bestConfidence = 0;
                let allTexts = [];
                
                for (let i = 0; i < configs.length; i++) {
                    const config = configs[i];
                    console.log(`🔄 Trying OCR configuration ${i + 1}: ${config.lang}`);
                    updateScanStatus(side, 'loading', `OCR Versuch ${i + 1}/3 (${config.lang})...`);
                    
                    try {
                        const result = await Tesseract.recognize(
                            preprocessedBlob || imageBlob, 
                            config.lang, 
                            {
                                logger: (m) => {
                                    console.log(`Tesseract ${side} config ${i + 1}:`, m);
                                    if (m.status === 'recognizing text') {
                                        const progress = Math.round(m.progress * 100);
                                        updateScanStatus(side, 'loading', `OCR ${i + 1}/3: ${progress}% (${config.lang})`);
                                    }
                                },
                                ...config.options
                            }
                        );
                        
                        const confidence = result.data.confidence || 0;
                        const textLength = result.data.text ? result.data.text.length : 0;
                        
                        console.log(`📊 Config ${i + 1} result:`, {
                            confidence: confidence,
                            text_length: textLength,
                            text_preview: result.data.text ? result.data.text.substring(0, 100) : 'NO TEXT'
                        });
                        
                        // Store ALL results for combination
                        allTexts.push({
                            text: result.data.text || '',
                            confidence: confidence,
                            config: i + 1
                        });
                        
                        if (confidence > bestConfidence) {
                            bestResult = result;
                            bestConfidence = confidence;
                            console.log(`✅ New best result with confidence ${bestConfidence}%`);
                        }
                        
                        // If we get a very good result with substantial text, we can break early
                        if (confidence > 80 && textLength > 30) {
                            console.log(`🎯 Excellent result found early, stopping at config ${i + 1}`);
                            break;
                        }
                        
                    } catch (configError) {
                        console.error(`❌ OCR config ${i + 1} failed:`, configError);
                        updateScanStatus(side, 'loading', `Config ${i + 1} fehlgeschlagen, versuche nächste...`);
                    }
                }
                
                if (!bestResult || !bestResult.data.text) {
                    console.error('❌ All OCR configurations failed to extract text');
                    throw new Error('Alle OCR-Konfigurationen lieferten keinen Text');
                }
                
                console.log(`🏆 Using best result (confidence: ${bestConfidence}%)`);
                console.log(`📝 Raw OCR text (${bestResult.data.text.length} chars):`, bestResult.data.text);
                console.log(`📋 All OCR attempts:`, allTexts);
                
                updateScanStatus(side, 'loading', `OCR abgeschlossen (${bestConfidence.toFixed(1)}%) - Text wird analysiert...`);
                
                // ENHANCED: Parse text with improved German card patterns
                const parsedData = parseInsuranceCardTextEnhanced(bestResult.data.text, side);
                
                // Try to combine insights from all OCR attempts if main result is weak
                if (bestConfidence < 60 && allTexts.length > 1) {
                    console.log('🔄 Low confidence, trying to combine all OCR results...');
                    const combinedParsed = combineAllOCRAttempts(allTexts, side);
                    if (hasBetterData(combinedParsed, parsedData)) {
                        parsedData = combinedParsed;
                        console.log('✅ Combined result is better, using that');
                    }
                }
                
                console.log(`✅ Final parsed data for ${side} side:`, parsedData);
                
                // More lenient success criteria
                const hasAnyValidData = side === 'front' ? 
                    (parsedData.name && parsedData.name !== 'Name nicht erkannt') ||
                    (parsedData.insurance_number && parsedData.insurance_number !== 'Versichertennummer nicht erkannt') ||
                    (parsedData.insurance_company && parsedData.insurance_company !== 'Krankenkasse nicht erkannt') :
                    (parsedData.valid_until && parsedData.valid_until !== 'Gültigkeitsdatum nicht erkannt') ||
                    (parsedData.birth_date && parsedData.birth_date !== 'Geburtsdatum nicht erkannt');
                
                const isSuccess = hasAnyValidData || bestResult.data.text.length > 20; // Success if we found ANY data OR got substantial text
                
                return {
                    success: isSuccess,
                    data: parsedData,
                    confidence: bestResult.data.confidence / 100,
                    raw_text: bestResult.data.text,
                    method: 'tesseract_enhanced',
                    all_attempts: allTexts.length
                };
                
            } catch (error) {
                console.error('❌ Enhanced Tesseract OCR error:', error);
                updateScanStatus(side, 'loading', `Tesseract fehlgeschlagen: ${error.message}`);
                return {
                    success: false,
                    error: error.message,
                    method: 'tesseract_failed'
                };
            }
        }
        
        // NEW: Image preprocessing for better OCR
        async function preprocessImageForOCR(imageBlob, side) {
            try {
                console.log(`🖼️ Preprocessing image for ${side} side OCR...`);
                
                // Create canvas for image processing
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // Load image
                const img = new Image();
                await new Promise((resolve, reject) => {
                    img.onload = resolve;
                    img.onerror = reject;
                    img.src = URL.createObjectURL(imageBlob);
                });
                
                // Set canvas size (increase resolution for better OCR)
                canvas.width = Math.min(img.width * 2, 2000); // Max 2000px width
                canvas.height = Math.min(img.height * 2, 1500); // Max 1500px height
                
                // Draw and enhance image
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                
                // Get image data for processing
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                
                // Apply enhancements for better OCR
                for (let i = 0; i < data.length; i += 4) {
                    // Convert to grayscale with proper weights
                    const gray = Math.round(0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]);
                    
                    // Enhance contrast (make text darker, background lighter)
                    let enhanced = gray;
                    if (enhanced < 128) {
                        enhanced = Math.max(0, enhanced - 30); // Darken dark areas (text)
                    } else {
                        enhanced = Math.min(255, enhanced + 30); // Lighten light areas (background)
                    }
                    
                    // Apply threshold for binary image (better for OCR)
                    enhanced = enhanced > 140 ? 255 : 0;
                    
                    data[i] = enhanced;     // Red
                    data[i + 1] = enhanced; // Green
                    data[i + 2] = enhanced; // Blue
                    // Alpha stays the same
                }
                
                // Put processed data back
                ctx.putImageData(imageData, 0, 0);
                
                // Convert back to blob
                return new Promise((resolve) => {
                    canvas.toBlob((processedBlob) => {
                        console.log(`✅ Image preprocessed: ${imageBlob.size} → ${processedBlob.size} bytes`);
                        resolve(processedBlob);
                    }, 'image/png', 1.0); // High quality PNG for OCR
                });
                
            } catch (error) {
                console.error('❌ Image preprocessing failed:', error);
                return null; // Return null to use original image
            }
        }
        
        // NEW: Combine multiple OCR attempts
        function combineAllOCRAttempts(allTexts, side) {
            console.log(`🔗 Combining ${allTexts.length} OCR attempts for ${side} side`);
            
            const combined = {
                name: '',
                insurance_number: '',
                insurance_company: '',
                birth_date: '',
                valid_until: ''
            };
            
            // Parse each text and find best values
            for (const textResult of allTexts) {
                if (!textResult.text || textResult.text.length < 5) continue;
                
                const parsed = parseInsuranceCardTextEnhanced(textResult.text, side);
                
                // For each field, keep the longest/best value
                for (const [key, value] of Object.entries(parsed)) {
                    if (value && value.length > 3 && !value.includes('nicht erkannt')) {
                        if (!combined[key] || value.length > combined[key].length) {
                            combined[key] = value;
                            console.log(`📝 Updated ${key} from config: ${value}`);
                        }
                    }
                }
            }
            
            // Fill missing fields with appropriate fallbacks
            if (side === 'front') {
                if (!combined.name) combined.name = 'Name nicht erkannt';
                if (!combined.insurance_number) combined.insurance_number = 'Versichertennummer nicht erkannt';
                if (!combined.insurance_company) combined.insurance_company = 'Krankenkasse nicht erkannt';
            } else {
                if (!combined.valid_until) combined.valid_until = 'Gültigkeitsdatum nicht erkannt';
                if (!combined.birth_date) combined.birth_date = 'Geburtsdatum nicht erkannt';
            }
            
            console.log('✅ Combined OCR result:', combined);
            return combined;
        }
        
        // NEW: Check if one parsed result is better than another
        function hasBetterData(newData, oldData) {
            let newScore = 0;
            let oldScore = 0;
            
            for (const [key, value] of Object.entries(newData)) {
                if (value && !value.includes('nicht erkannt')) newScore++;
            }
            
            for (const [key, value] of Object.entries(oldData)) {
                if (value && !value.includes('nicht erkannt')) oldScore++;
            }
            
            return newScore > oldScore;
        }

        // ENHANCED: Better parsing for German insurance cards
        function parseInsuranceCardTextEnhanced(text, side) {
            console.log(`🔍 ENHANCED parsing ${side} side text:`, text);
            
            if (!text || text.trim().length < 5) {
                console.log('⚠️ Text too short for parsing');
                return getMinimalFallbackData(side);
            }
            
            const lines = text.split('\n').map(line => line.trim()).filter(line => line.length > 1);
            console.log(`📋 Processing ${lines.length} lines:`, lines);
            
            const data = {};
            
            if (side === 'front') {
                // Enhanced front side parsing
                data.name = extractNameEnhanced(lines);
                data.insurance_number = extractInsuranceNumberEnhanced(lines);
                data.insurance_company = extractInsuranceCompanyEnhanced(lines);
                data.birth_date = extractBirthDateEnhanced(lines);
                
            } else {
                // Enhanced back side parsing
                data.valid_until = extractValidUntilEnhanced(lines);
                data.birth_date = extractBirthDateEnhanced(lines);
            }
            
            console.log(`✅ Enhanced parsed ${side} side data:`, data);
            return data;
        }

        // ENHANCED extraction functions with better patterns
        function extractNameEnhanced(lines) {
            console.log('🔍 Looking for name in lines:', lines);
            
            for (const line of lines) {
                // Skip header lines and institutional info
                if (/kranken|versichert|insurance|european|health|bundesrepublik|ik-nummer|gültig/i.test(line)) {
                    continue;
                }
                
                // German eGK name patterns - more specific for German cards
                const namePatterns = [
                    // Standard format: "MUSTERMANN, MAX" or "Mustermann, Max"
                    /^([A-ZÄÖÜ][A-ZÄÖÜß\s\-]{1,25}),\s*([A-ZÄÖÜ][A-Za-zäöüß\s\-]{1,25})$/,
                    // Standard format: "Max Mustermann" 
                    /^([A-ZÄÖÜ][a-zäöüß]{2,15})\s+([A-ZÄÖÜ][A-Za-zäöüß\s\-]{2,25})$/,
                    // All caps format: "MAX MUSTERMANN"
                    /^([A-ZÄÖÜ]{2,15})\s+([A-ZÄÖÜ\s\-]{2,25})$/,
                    // With titles: "Dr. Max Mustermann", "Prof. Dr. ..."
                    /^(?:Dr\.?\s*|Prof\.?\s*Dr\.?\s*)?([A-ZÄÖÜ][a-zäöüß]{2,15})\s+([A-ZÄÖÜ][A-Za-zäöüß\s\-]{2,25})$/
                ];
                
                for (const pattern of namePatterns) {
                    const match = line.match(pattern);
                    if (match) {
                        let name;
                        if (match.length === 3) {
                            // Two parts found (first name, last name)
                            name = match[2].trim() + ' ' + match[1].trim(); // "Max Mustermann" format
                        } else {
                            name = line.trim();
                        }
                        
                        // Validate name length and content
                        if (name.length >= 4 && name.length <= 50) {
                            console.log(`✅ Found name: "${name}"`);
                            return name;
                        }
                    }
                }
                
                // Fallback: Look for any line with 2-3 capitalized words (German naming convention)
                const words = line.split(/\s+/).filter(w => w.length > 1);
                if (words.length >= 2 && words.length <= 3) {
                    const isGermanName = words.every(word => 
                        /^[A-ZÄÖÜ][a-zäöüß\-]*$/.test(word) || 
                        /^[A-ZÄÖÜ]{2,}$/.test(word)
                    );
                    if (isGermanName && line.length >= 4 && line.length <= 50) {
                        console.log(`✅ Found name (fallback): "${line}"`);
                        return line.trim();
                    }
                }
            }
            
            console.log('❌ No name found');
            return 'Name nicht erkannt';
        }

        function extractInsuranceNumberEnhanced(lines) {
            console.log('🔍 Looking for KVNR (Versichertennummer) in lines:', lines);
            
            for (const line of lines) {
                // German KVNR patterns according to § 291 SGB V
                const kvnrPatterns = [
                    // Standard KVNR: Buchstabe + 9 Ziffern (X123456789)
                    /([A-Z]\d{9})/g,
                    // With spaces: X 123 456 789
                    /([A-Z]\s?\d{3}\s?\d{3}\s?\d{3})/g,
                    // With dots: X.123.456.789
                    /([A-Z]\.?\d{3}\.?\d{3}\.?\d{3})/g,
                    // Legacy 10-digit format (still used by some insurers)
                    /(\d{10})/g,
                    // With separators: 1234 567 890
                    /(\d{4}\s?\d{3}\s?\d{3})/g
                ];
                
                for (const pattern of kvnrPatterns) {
                    const matches = [...line.matchAll(pattern)];
                    for (const match of matches) {
                        const number = match[1].replace(/[\s\.\-]/g, ''); // Remove separators
                        
                        // Validate KVNR format
                        if (isValidGermanKVNR(number)) {
                            console.log(`✅ Found valid KVNR: "${number}"`);
                            return number;
                        }
                    }
                }
            }
            
            console.log('❌ No valid KVNR found');
            return 'Versichertennummer nicht erkannt';
        }

        function extractInsuranceCompanyEnhanced(lines) {
            console.log('🔍 Looking for German health insurance company in lines:', lines);
            
            // Complete list of German health insurance companies (Krankenkassen)
            const germanInsurers = [
                // Major AOK regional branches
                'AOK Baden-Württemberg', 'AOK Bayern', 'AOK Bremen/Bremerhaven', 'AOK Hessen',
                'AOK Niedersachsen', 'AOK Nordost', 'AOK Nordwest', 'AOK PLUS', 'AOK Rheinland/Hamburg',
                'AOK Rheinland-Pfalz/Saarland', 'AOK Sachsen-Anhalt', 'AOK Westfalen-Lippe',
                
                // Major company health funds (BKK)
                'BKK Mobil Oil', 'BKK24', 'BKK VBU', 'BKK Pfalz', 'BKK Dürkopp Adler',
                'BKK firmus', 'BKK Gildemeister Seidensticker', 'BKK Mahle', 'BKK Melitta Plus',
                'BKK ProVita', 'BKK Scheufelen', 'BKK Textilgruppe Hof', 'BKK Mobil Oil',
                
                // Guild health funds (IKK)
                'IKK classic', 'IKK gesund plus', 'IKK Nord', 'IKK Südwest',
                
                // Major substitute funds (Ersatzkassen)
                'Techniker Krankenkasse', 'TK', 'Barmer', 'DAK-Gesundheit', 'DAK', 'KKH',
                'HEK - Hanseatische Krankenkasse', 'hkk', 'Pronova BKK',
                
                // Special insurance funds
                'Knappschaft', 'SVLFG', 'Sozialversicherung für Landwirtschaft',
                
                // Private health insurers (common in mixed systems)
                'Continentale', 'Debeka', 'Signal Iduna', 'HanseMerkur', 'Allianz Private',
                'AXA', 'DKV', 'Württembergische', 'Central', 'Universa', 'Hallesche'
            ];
            
            for (const line of lines) {
                const lineUpper = line.toUpperCase();
                
                // Check for exact or partial matches with German insurers
                for (const insurer of germanInsurers) {
                    const insurerUpper = insurer.toUpperCase();
                    
                    // Check for exact match or significant overlap
                    if (lineUpper.includes(insurerUpper) || insurerUpper.includes(lineUpper)) {
                        console.log(`✅ Found insurance company: "${line}"`);
                        return line.trim();
                    }
                    
                    // Check for abbreviated forms (TK, AOK, etc.)
                    const abbreviations = {
                        'TK': 'Techniker Krankenkasse',
                        'AOK': 'AOK',
                        'DAK': 'DAK-Gesundheit',
                        'BKK': 'Betriebskrankenkasse',
                        'IKK': 'Innungskrankenkasse',
                        'KKH': 'Kaufmännische Krankenkasse'
                    };
                    
                    for (const [abbr, full] of Object.entries(abbreviations)) {
                        if (lineUpper.includes(abbr) && line.length <= 30) {
                            console.log(`✅ Found insurance company (abbreviated): "${line}"`);
                            return line.trim();
                        }
                    }
                }
                
                // Check for generic German health insurance terms
                const germanTerms = [
                    'krankenkasse', 'krankenversicherung', 'gesundheitskasse', 
                    'versicherung', 'kasse', 'ersatzkasse', 'betriebskrankenkasse'
                ];
                
                for (const term of germanTerms) {
                    if (lineUpper.includes(term.toUpperCase()) && line.length > 5 && line.length < 50) {
                        console.log(`✅ Found insurance company (generic): "${line}"`);
                        return line.trim();
                    }
                }
            }
            
            console.log('❌ No insurance company found');
            return 'Krankenkasse nicht erkannt';
        }

        function extractBirthDateEnhanced(lines) {
            console.log('🔍 Looking for birth date in lines:', lines);
            
            for (const line of lines) {
                // German date patterns (DD.MM.YYYY is standard)
                const datePatterns = [
                    // Standard German format: DD.MM.YYYY
                    /(?:geb\.?:?\s*|geboren:?\s*|birth:?\s*)?(\d{1,2}\.\d{1,2}\.\d{4})/i,
                    // Alternative with slashes: DD/MM/YYYY
                    /(?:geb\.?:?\s*|geboren:?\s*)?(\d{1,2}\/\d{1,2}\/\d{4})/i,
                    // Alternative with dashes: DD-MM-YYYY
                    /(?:geb\.?:?\s*|geboren:?\s*)?(\d{1,2}-\d{1,2}-\d{4})/i,
                    // Short format: DD.MM.YY
                    /(?:geb\.?:?\s*|geboren:?\s*)?(\d{1,2}\.\d{1,2}\.\d{2})/i,
                    // Without separators: DDMMYYYY
                    /(?:geb\.?:?\s*|geboren:?\s*)?(\d{8})/i
                ];
                
                for (const pattern of datePatterns) {
                    const match = line.match(pattern);
                    if (match) {
                        let date = match[1];
                        
                        // Validate German date format
                        if (isValidGermanDate(date)) {
                            console.log(`✅ Found birth date: "${date}"`);
                            return date;
                        }
                    }
                }
            }
            
            console.log('❌ No birth date found');
            return 'Geburtsdatum nicht erkannt';
        }

        function extractValidUntilEnhanced(lines) {
            console.log('🔍 Looking for card validity date in lines:', lines);
            
            for (const line of lines) {
                // German validity date patterns (usually MM/YY or MM.YYYY)
                const validityPatterns = [
                    // Standard format: MM/YY (Ende 12/25)
                    /(?:gültig bis:?\s*|bis:?\s*|ende:?\s*|valid until:?\s*|exp\.?:?\s*)?(\d{1,2}\/\d{2,4})/i,
                    // Alternative: MM.YY
                    /(?:gültig bis:?\s*|bis:?\s*|ende:?\s*)?(\d{1,2}\.\d{2,4})/i,
                    // Full date: DD.MM.YYYY
                    /(?:gültig bis:?\s*|bis:?\s*|ende:?\s*)?(\d{1,2}\.\d{1,2}\.\d{4})/i,
                    // Month year spelled out: "Ende 12/2025"
                    /(?:ende|gültig bis|bis)\s*(\d{1,2}\/\d{4})/i
                ];
                
                for (const pattern of validityPatterns) {
                    const match = line.match(pattern);
                    if (match) {
                        const validityDate = match[1];
                        console.log(`✅ Found validity date: "${validityDate}"`);
                        return validityDate;
                    }
                }
            }
            
            console.log('❌ No validity date found');
            return 'Gültigkeitsdatum nicht erkannt';
        }
        
        // Helper function to validate German KVNR format
        function isValidGermanKVNR(kvnr) {
            if (!kvnr || typeof kvnr !== 'string') return false;
            
            // Remove any spaces or separators
            const clean = kvnr.replace(/[\s\.\-]/g, '');
            
            // Standard format: Letter + 9 digits (X123456789)
            if (/^[A-Z]\d{9}$/.test(clean)) {
                console.log(`✅ Valid KVNR format (letter + 9 digits): ${clean}`);
                return true;
            }
            
            // Legacy format: 10 digits
            if (/^\d{10}$/.test(clean)) {
                console.log(`✅ Valid KVNR format (10 digits): ${clean}`);
                return true;
            }
            
            console.log(`❌ Invalid KVNR format: ${clean}`);
            return false;
        }
        
        // Helper function to validate German date format
        function isValidGermanDate(dateStr) {
            if (!dateStr) return false;
            
            // Check various German date patterns
            const patterns = [
                /^\d{1,2}\.\d{1,2}\.\d{4}$/, // DD.MM.YYYY
                /^\d{1,2}\/\d{1,2}\/\d{4}$/, // DD/MM/YYYY  
                /^\d{1,2}-\d{1,2}-\d{4}$/,   // DD-MM-YYYY
                /^\d{1,2}\.\d{1,2}\.\d{2}$/,  // DD.MM.YY
                /^\d{8}$/                     // DDMMYYYY
            ];
            
            return patterns.some(pattern => pattern.test(dateStr));
        }

        // Backend OCR fallback
        async function performBackendOCR(imageBlob, side) {
            try {
                console.log(`🔄 Starting Backend OCR for ${side} side (image size: ${imageBlob.size} bytes)`);
                updateScanStatus(side, 'loading', 'Backend OCR wird verwendet...');
                
                // Convert blob to base64 for debugging
                const base64 = await blobToBase64(imageBlob);
                console.log(`📋 Image converted to base64 (${base64.length} chars)`);
                
                const formData = new FormData();
                formData.append('image', imageBlob);
                formData.append('side', side);
                formData.append('meeting_id', meetingId);
                
                console.log(`🌐 Sending request to backend OCR endpoint...`);
                const startTime = Date.now();
                
                const response = await fetch('/api/ocr/process-card', {
                    method: 'POST',
                    body: formData
                });
                
                const responseTime = Date.now() - startTime;
                console.log(`⏱️ Backend OCR response time: ${responseTime}ms`);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`❌ Backend OCR HTTP error ${response.status}:`, errorText);
                    throw new Error(`Backend OCR request failed: ${response.status} ${response.statusText}`);
                }
                
                const result = await response.json();
                console.log(`📥 Backend OCR response:`, result);
                
                if (result.success) {
                    console.log(`✅ Backend OCR successful:`, result.data);
                    console.log(`📝 Backend raw text:`, result.raw_text || 'No raw text provided');
                    updateScanStatus(side, 'loading', 'Backend-Ergebnisse erfolgreich analysiert!');
                    
                    return {
                        success: true,
                        data: result.data,
                        confidence: result.confidence || 0.8,
                        raw_text: result.raw_text || '',
                        method: 'backend_pytesseract'
                    };
                } else {
                    console.error(`❌ Backend OCR failed:`, result.error || 'Unknown backend error');
                    throw new Error(result.error || 'Backend OCR failed');
                }
                
            } catch (error) {
                console.error('❌ Backend OCR error:', error);
                
                // If it's a network error, provide more details
                if (error.name === 'TypeError' && error.message.includes('fetch')) {
                    console.error('🌐 Network error - backend may be unreachable');
                    updateScanStatus(side, 'loading', 'Backend nicht erreichbar - verwende Fallback...');
                } else {
                    updateScanStatus(side, 'loading', `Backend-Fehler: ${error.message}`);
                }
                
                // Enhanced fallback: return success with debug info to not block user
                console.log('🔄 Using enhanced fallback to continue workflow');
                return {
                    success: true, // Return success to not block user
                    data: {
                        ...getMinimalFallbackData(side),
                        debug_info: `Backend failed: ${error.message}`,
                        debug_timestamp: new Date().toISOString()
                    },
                    confidence: 0.1,
                    raw_text: `Backend OCR Error: ${error.message}`,
                    method: 'backend_fallback'
                };
            }
        }

        // NEW: Parse German insurance card text
        function parseInsuranceCardText(text, side) {
            console.log(`🔍 Parsing ${side} side text:`, text);
            
            const lines = text.split('\n').map(line => line.trim()).filter(line => line.length > 1);
            const data = {};
            
            if (side === 'front') {
                // Parse front side data
                data.name = extractName(lines);
                data.insurance_number = extractInsuranceNumber(lines);
                data.insurance_company = extractInsuranceCompany(lines);
                data.birth_date = extractBirthDate(lines);
                
            } else {
                // Parse back side data
                data.valid_until = extractValidUntil(lines);
                data.birth_date = extractBirthDate(lines);
            }
            
            console.log(`✅ Parsed ${side} side data:`, data);
            return data;
        }

        // NEW: Text extraction functions
        function extractName(lines) {
            for (const line of lines) {
                // Look for name patterns (2-4 words, letters only)
                if (/^[A-ZÄÖÜ][a-zäöüß]+ [A-ZÄÖÜ][a-zäöüß]+/.test(line)) {
                    const words = line.split(' ').filter(w => /^[A-Za-zÄÖÜäöüß\-]+$/.test(w));
                    if (words.length >= 2 && words.length <= 4) {
                        return words.join(' ');
                    }
                }
            }
            return 'Name nicht erkannt';
        }

        function extractInsuranceNumber(lines) {
            for (const line of lines) {
                // German insurance numbers: Letter + 9 digits or 10 digits
                const match = line.match(/([A-Z]\d{9}|\d{10})/);
                if (match) {
                    return match[1];
                }
            }
            return 'Nummer nicht erkannt';
        }

        function extractInsuranceCompany(lines) {
            const companies = [
                'AOK', 'TK', 'Techniker', 'Barmer', 'DAK', 'KKH', 'HEK', 
                'BKK', 'IKK', 'Knappschaft', 'SVLFG', 'Continentale',
                'Debeka', 'Signal', 'HanseMerkur'
            ];
            
            for (const line of lines) {
                for (const company of companies) {
                    if (line.toUpperCase().includes(company.toUpperCase())) {
                        return line;
                    }
                }
            }
            return 'Krankenkasse nicht erkannt';
        }

        function extractBirthDate(lines) {
            for (const line of lines) {
                // Date patterns: DD.MM.YYYY or DD/MM/YYYY
                const match = line.match(/(\d{1,2}[\.\-\/]\d{1,2}[\.\-\/]\d{2,4})/);
                if (match) {
                    return match[1];
                }
            }
            return '';
        }

        function extractValidUntil(lines) {
            for (const line of lines) {
                // Look for validity date patterns
                const match = line.match(/(?:gültig bis:?\s*|bis:?\s*)?(\d{1,2}\/\d{2,4}|\d{1,2}\.\d{2,4})/i);
                if (match) {
                    return match[1];
                }
            }
            return 'Gültigkeitsdatum nicht erkannt';
        }

        function getMinimalFallbackData(side) {
            const timestamp = new Date().toLocaleTimeString();
            
            if (side === 'front') {
                return {
                    name: `📸 Bild erfasst ${timestamp}`,
                    insurance_number: `🔍 OCR versucht ${timestamp}`,
                    insurance_company: `⚠️ Text nicht erkannt ${timestamp}`
                };
            } else {
                return {
                    valid_until: `📸 Rückseite erfasst ${timestamp}`,
                    birth_date: `🔍 OCR versucht ${timestamp}`
                };
            }
        }

        // NEW: Show countdown overlay - UPDATED: Smaller, non-blocking countdown
        function showCountdownOverlay(side) {
            // Create a small countdown indicator in the corner instead of full overlay
            const countdownIndicator = document.createElement('div');
            countdownIndicator.id = `${side}CountdownIndicator`;
            countdownIndicator.className = 'countdown-indicator';
            countdownIndicator.style.cssText = `
                position: absolute;
                top: 10px;
                right: 10px;
                background: rgba(40, 167, 69, 0.9);
                color: white;
                padding: 8px 16px;
                border-radius: 20px;
                font-size: 1.2rem;
                font-weight: bold;
                z-index: 50;
                border: 2px solid #28a745;
                box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            `;
            
            countdownIndicator.innerHTML = `
                <div style="display: flex; align-items: center; gap: 8px;">
                    <div id="${side}CountdownNumber" style="font-size: 1.4rem;">5</div>
                    <div style="font-size: 0.9rem;">Sek.</div>
                </div>
            `;
            
            const scanner = document.querySelector(`#${side}SideStep .card-scanner`);
            scanner.appendChild(countdownIndicator);
        }

        // NEW: Update countdown display - UPDATED: Just update the number
        function updateCountdownDisplay(side, number) {
            const numberElement = document.getElementById(`${side}CountdownNumber`);
            if (numberElement) {
                numberElement.textContent = number;
                // Add a little pulse animation
                numberElement.style.transform = 'scale(1.2)';
                setTimeout(() => {
                    if (numberElement) numberElement.style.transform = 'scale(1)';
                }, 200);
            }
        }

        // NEW: Hide countdown indicator - UPDATED: Remove the small indicator
        function hideCountdownOverlay(side) {
            const indicator = document.getElementById(`${side}CountdownIndicator`);
            if (indicator) {
                indicator.remove();
            }
        }

        // Manual scan functions
        async function manualScanFront() {
            console.log('📸 Manual front side scan triggered');
            
            // Stop automatic detection
            stopAutomaticDetection();
            
            // Update status
            updateScanStatus('front', 'loading', 'Manueller Scan wird durchgeführt...');
            updateCardFrame('front', 'detected');
            
            try {
                // Use real OCR processing
                await captureAndProcessSimplified('front');
            } catch (error) {
                console.error('Manual front scan error:', error);
                updateScanStatus('front', 'error', 'Manueller Scan fehlgeschlagen');
                
                // Show retry option
                setTimeout(() => {
                    updateScanStatus('front', 'ready', 'Bereit für Vorderseite-Scan. Klicken Sie "Countdown starten" wenn Sie bereit sind.');
                }, 3000);
            }
        }

        async function manualScanBack() {
            console.log('📸 Manual back side scan triggered');
            
            // Stop automatic detection
            stopAutomaticDetection();
            
            // Update status
            updateScanStatus('back', 'loading', 'Manueller Scan wird durchgeführt...');
            updateCardFrame('back', 'detected');
            
            try {
                // Use real OCR processing
                await captureAndProcessSimplified('back');
            } catch (error) {
                console.error('Manual back scan error:', error);
                updateScanStatus('back', 'error', 'Manueller Scan fehlgeschlagen');
                
                // Show retry option
                setTimeout(() => {
                    updateScanStatus('back', 'ready', 'Bereit für Rückseite-Scan. Klicken Sie "Countdown starten" wenn Sie bereit sind.');
                }, 3000);
            }
        }

        // ENHANCED: Fully automatic card detection and processing
        async function onCardDetected(side, detectionResult) {
            console.log(`✅ Insurance card ${side} side detected!`, detectionResult);
            
            stopAutomaticDetection();
            
            // Check quality before proceeding
            if (detectionResult.cardType === 'poor_quality') {
                handlePoorQuality(side, detectionResult.quality);
                return;
            }
            
            if (!detectionResult.isInsuranceCard) {
                handleWrongCardType(side, detectionResult.cardType);
                return;
            }
            
            // Show auto-detected state
            updateCardFrame(side, 'auto-detected');
            updateScanStatus(side, 'success', `${side === 'front' ? 'Vorderseite' : 'Rückseite'} erkannt!`);
            
            // Start countdown for automatic scanning
            await startAutoScanCountdown(side);
        }

        // NEW: Automatic scan countdown
        async function startAutoScanCountdown(side) {
            const countdownElement = document.getElementById(`${side}AutoProcessing`);
            const countdownNumber = document.getElementById(`${side}CountdownNumber`);
            const countdownText = document.getElementById(`${side}CountdownText`);
            
            // Show countdown
            countdownElement.style.display = 'block';
            
            // 3 second countdown
            for (let i = 3; i > 0; i--) {
                countdownNumber.textContent = i;
                countdownText.textContent = i;
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
            
            // Hide countdown and start scan
            countdownElement.style.display = 'none';
            
            // Auto-scan the current frame
            updateScanStatus(side, 'loading', 'Automatischer Scan läuft...');
            const imageBlob = await captureCardImage(side);
            await processSideWithOCR(imageBlob, side);
        }

        // Handle poor image quality
        function handlePoorQuality(side, quality) {
            const guidanceElement = document.getElementById(`${side}QualityGuidance`);
            const guidanceText = document.getElementById(`${side}GuidanceText`);
            
            // Show specific guidance based on quality issues
            let message = 'Bitte verbessern Sie die Bildqualität';
            
            if (quality.sharpness < 50) {
                message = 'Karte bitte ruhiger halten - zu unscharf';
            } else if (quality.brightness < 50) {
                message = 'Bessere Beleuchtung benötigt - zu dunkel';
            } else if (quality.brightness > 200) {
                message = 'Weniger direktes Licht - zu hell';
            }
            
            guidanceText.textContent = message;
            guidanceElement.style.display = 'block';
            
            updateScanStatus(side, 'error', message);
            updateCardFrame(side, 'error');
            
            // Hide guidance and retry after 3 seconds
            setTimeout(() => {
                guidanceElement.style.display = 'none';
                restartDetection(side);
            }, 3000);
        }

        // Handle wrong card type
        function handleWrongCardType(side, cardType) {
            const guidanceElement = document.getElementById(`${side}QualityGuidance`);
            const guidanceText = document.getElementById(`${side}GuidanceText`);
            
            let message = 'Bitte deutsche Krankenkassenkarte verwenden';
            
            if (cardType === 'id') {
                message = 'Das ist ein Ausweis - bitte Krankenkassenkarte zeigen';
            } else if (cardType === 'credit') {
                message = 'Das ist eine Kreditkarte - bitte Krankenkassenkarte zeigen';
            }
            
            guidanceText.textContent = message;
            guidanceElement.style.display = 'block';
            
            updateScanStatus(side, 'error', message);
            updateCardFrame(side, 'error');
            
            // Hide guidance and retry after 4 seconds
            setTimeout(() => {
                guidanceElement.style.display = 'none';
                restartDetection(side);
            }, 4000);
        }

        // Restart detection after error
        function restartDetection(side) {
            detectionAttempts = 0;
            stableFrameCount = 0;
            updateScanStatus(side, 'ready', `Bereit für ${side === 'front' ? 'Vorderseite' : 'Rückseite'}-Scan`);
            updateCardFrame(side, 'detecting');
            startAutomaticDetection(side);
        }

        // ENHANCED: More sophisticated error handling
        function onDetectionTimeout(side) {
            console.log(`⏰ Detection timeout for ${side} side`);
            
            stopAutomaticDetection();
            
            const guidanceElement = document.getElementById(`${side}QualityGuidance`);
            const guidanceText = document.getElementById(`${side}GuidanceText`);
            
            guidanceText.textContent = 'Keine Karte erkannt - bitte in den Rahmen halten';
            guidanceElement.style.display = 'block';
            
            updateScanStatus(side, 'error', 'Keine Karte erkannt - bitte Tipps befolgen');
            updateCardFrame(side, 'error');
            
            // Auto-retry after guidance
            setTimeout(() => {
                guidanceElement.style.display = 'none';
                restartDetection(side);
            }, 5000);
        }

        async function extractCardData(side) {
            try {
                updateScanStatus(side, 'loading', `${side === 'front' ? 'Vorderseite' : 'Rückseite'} wird verarbeitet...`);
                
                // Capture current frame for OCR
                const imageBlob = await captureCardImage(side);
                
                // Process with OCR
                await processSideWithOCR(imageBlob, side);
                
            } catch (error) {
                console.error(`Data extraction error for ${side}:`, error);
                updateScanStatus(side, 'error', 'Datenextraktion fehlgeschlagen');
                showErrorGuidance('extraction_failed');
            }
        }

        async function processSideWithOCR(imageBlob, side) {
            try {
                console.log(`🔍 Processing ${side} side with OCR...`);
                
                const ocrResult = await performTesseractOCR(imageBlob, side);
                
                if (ocrResult.success) {
                    if (side === 'front') {
                        frontCardData = ocrResult.data;
                        console.log('✅ Front side data extracted:', frontCardData);
                        
                        // Move to back side scanning
                        currentScanStep = 'back';
                        await startBackSideScanning();
                        
                    } else {
                        backCardData = ocrResult.data;
                        console.log('✅ Back side data extracted:', backCardData);
                        
                        // Combine data from both sides and show confirmation
                        combineCardData();
                    }
                } else {
                    throw new Error(ocrResult.error || 'OCR-Verarbeitung fehlgeschlagen');
                }
                
            } catch (error) {
                console.error(`OCR processing error for ${side}:`, error);
                updateScanStatus(side, 'error', 'OCR fehlgeschlagen');
                
                if (error.message.includes('Bildqualität')) {
                    showOCRQualityGuidance();
                } else if (error.message.includes('verwertbaren Kartendaten')) {
                    showOCRPositioningGuidance();
                } else {
                    showErrorGuidance('extraction_failed');
                }
            }
        }

        function combineCardData() {
            console.log('🔗 Combining front and back side data...');
            
            // Merge data from both sides, preferring front side for primary data
            extractedCardData = {
                name: frontCardData?.name || 'Nicht erkannt',
                insuranceNumber: frontCardData?.insurance_number || 'Nicht erkannt',
                insuranceCompany: frontCardData?.insurance_company || 'Nicht erkannt',
                validUntil: backCardData?.valid_until || 'Nicht erkannt',
                birthDate: backCardData?.birth_date || 'Nicht erkannt'
            };
            
            console.log('✅ Combined card data:', extractedCardData);
            
            // Show final confirmation
            showDataConfirmation();
        }

        async function captureCardImage(side) {
            return await captureCardImageFromVideo(side);
        }

        function stopAutomaticDetection() {
            isDetecting = false;
            if (detectionInterval) {
                clearInterval(detectionInterval);
                detectionInterval = null;
            }
        }

        // Updated helper functions
        function updateScanStatus(side, type, message) {
            const statusDiv = document.getElementById(`${side}SideStatus`);
            if (statusDiv) {
                // Mapping für alle Statusmeldungen
                let displayMessage = message;
                if (type === 'ready') {
                    displayMessage = side === 'front'
                        ? 'Bitte halten Sie die Vorderseite Ihrer Karte bereit und klicken Sie auf "Countdown starten".'
                        : 'Bitte drehen Sie die Karte um, halten Sie die Rückseite bereit und klicken Sie auf "Countdown starten".';
                } else if (type === 'detecting') {
                    displayMessage = 'Countdown läuft...';
                } else if (type === 'loading') {
                    displayMessage = 'Ihre Karte wird erfasst. Bitte halten Sie die Karte ruhig.';
                } else if (type === 'success') {
                    displayMessage = side === 'front'
                        ? 'Vielen Dank, Sie können die Karte jetzt entfernen.'
                        : 'Vielen Dank, Ihre Karte wurde gelesen.';
                } else if (type === 'error') {
                    displayMessage = 'Es ist ein Fehler aufgetreten. Bitte versuchen Sie es erneut.';
                }
                statusDiv.textContent = displayMessage;
                statusDiv.className = `scan-status ${type}`;
            }
        }

        function updateCardFrame(side, state) {
            const frameDiv = document.getElementById(`${side}CardFrame`);
            const textDiv = document.getElementById(`${side}CardFrameText`);
            
            if (frameDiv && textDiv) {
                frameDiv.className = `card-frame ${state}`;
                
                const sideText = side === 'front' ? 'Vorderseite' : 'Rückseite';
                switch (state) {
                    case 'detecting':
                        textDiv.textContent = `Suche nach ${sideText}...`;
                        break;
                    case 'detected':
                        textDiv.textContent = `${sideText} erkannt!`;
                        break;
                    case 'error':
                        textDiv.textContent = 'Bitte erneut versuchen';
                        break;
                    default:
                        textDiv.textContent = `${sideText} hier positionieren`;
                }
            }
        }

        function showCardTypeError(side, cardType) {
            console.log(`❌ Wrong card type detected for ${side} side:`, cardType);
            
            stopAutomaticDetection();
            updateScanStatus(side, 'error', `Falsche Karte erkannt: ${getCardTypeName(cardType)}`);
            updateCardFrame(side, 'error');
            
            // Show error guidance
            showErrorGuidance('wrong_card');
        }

        function showOCRQualityGuidance() {
            const errorDiv = document.getElementById('errorGuidance');
            const guidanceContent = errorDiv.querySelector('.guidance-content');
            
            guidanceContent.innerHTML = `
                <div style="font-size: 2rem; margin-bottom: 1rem;">📸</div>
                <h4>Bildqualität verbessern:</h4>
                <ul style="text-align: left; margin: 1rem 0;">
                    <li><strong>Beleuchtung:</strong> Sorgen Sie für helles, gleichmäßiges Licht</li>
                    <li><strong>Schärfe:</strong> Halten Sie die Kamera ruhig und fokussiert</li>
                    <li><strong>Abstand:</strong> Karte sollte den Rahmen vollständig ausfüllen</li>
                    <li><strong>Kontrast:</strong> Vermeiden Sie Schatten auf der Karte</li>
                    <li><strong>Sauberkeit:</strong> Reinigen Sie die Kameralinse</li>
                </ul>
                <button class="btn" onclick="retryCardDetection()">
                    🔄 Mit besserer Qualität erneut versuchen
                </button>
            `;
            
            errorDiv.style.display = 'block';
        }

        function showOCRPositioningGuidance() {
            const errorDiv = document.getElementById('errorGuidance');
            const guidanceContent = errorDiv.querySelector('.guidance-content');
            
            guidanceContent.innerHTML = `
                <div style="font-size: 2rem; margin-bottom: 1rem;">🎯</div>
                <h4>Karte besser positionieren:</h4>
                <ul style="text-align: left; margin: 1rem 0;">
                    <li><strong>Vollständig sichtbar:</strong> Ganze Karte im Rahmen zeigen</li>
                    <li><strong>Gerade halten:</strong> Karte nicht schräg oder gedreht</li>
                    <li><strong>Näher halten:</strong> Text sollte groß und lesbar sein</li>
                    <li><strong>Vorderseite:</strong> Stellen Sie sicher, dass es die Vorderseite ist</li>
                    <li><strong>Keine Reflexionen:</strong> Vermeiden Sie Lichtreflexionen</li>
                </ul>
                <button class="btn" onclick="retryCardDetection()">
                    🔄 Karte neu positionieren
                </button>
            `;
            
            errorDiv.style.display = 'block';
        }

        function showErrorGuidance(errorType) {
            const errorDiv = document.getElementById('errorGuidance');
            errorDiv.style.display = 'block';
            
            // Auto-hide after 10 seconds and retry
            setTimeout(() => {
                if (errorDiv.style.display !== 'none') {
                    retryCardDetection();
                }
            }, 10000);
        }

        function retryCardDetection() {
            console.log('🔄 Retrying card detection...');
            
            // Clear any existing safety timeout
            if (dataConfirmationTimeout) {
                clearTimeout(dataConfirmationTimeout);
                dataConfirmationTimeout = null;
                console.log('⏰ Safety timeout cleared for retry');
            }
            
            // Hide confirmation and error UI
            document.getElementById('dataConfirmation').style.display = 'none';
            document.getElementById('errorGuidance').style.display = 'none';
            
            // Show detection UI
            document.getElementById('cardScanningSteps').style.display = 'block';
            
            // Reset to front side
            document.getElementById('frontSideStep').style.display = 'block';
            document.getElementById('backSideStep').style.display = 'none';
            
            // Reset detection state
            detectionAttempts = 0;
            extractedCardData = null;
            frontCardData = null;
            backCardData = null;
            currentScanStep = 'front';
            
            // Manual scan buttons stay visible - no need to hide them
            console.log('✅ Manual scan buttons remain available');
            
            // Restart detection from front side
            startAutomaticDetection('front');
        }

        function confirmCardData(isCorrect) {
            if (isCorrect) {
                // Data confirmed - enable next step
                document.getElementById('step4Next').disabled = false;
                updateScanStatus('front', 'success', 'Kartendaten bestätigt!');
                updateScanStatus('back', 'success', 'Kartendaten bestätigt!');
                
                console.log('✅ Card data confirmed by user');
            } else {
                // User wants to retry - restart detection
                retryCardDetection();
            }
        }

        // NEW: Real OCR implementation with Tesseract.js - IMPROVED VERSION
        async function performTesseractOCR(imageBlob, side) {
            console.log(`🔍 Starting enhanced OCR for ${side} side...`);
            
            const progressBar = document.getElementById(`${side}OcrProgressBar`);
            const progressElement = document.getElementById(`${side}OcrProgress`);
            const progressText = document.getElementById(`${side}OcrProgressText`);
            
            // Show progress bar
            if (progressBar) progressBar.style.display = 'block';
            
            try {
                // Enhanced Tesseract configuration for German insurance cards
                const tesseractConfig = {
                    logger: (m) => {
                        console.log(`Tesseract ${side} side:`, m);
                        
                        if (progressElement && progressText) {
                            if (m.status === 'loading tesseract core') {
                                progressElement.style.width = '10%';
                                progressText.textContent = 'OCR-Kern lädt...';
                            } else if (m.status === 'initializing tesseract') {
                                progressElement.style.width = '20%';
                                progressText.textContent = 'OCR initialisiert...';
                            } else if (m.status === 'loading language traineddata') {
                                progressElement.style.width = '35%';
                                progressText.textContent = 'Deutsche Sprache...';
                            } else if (m.status === 'initializing api') {
                                progressElement.style.width = '45%';
                                progressText.textContent = 'API bereit...';
                            } else if (m.status === 'recognizing text') {
                                const progress = Math.round(m.progress * 100);
                                const totalProgress = 45 + (progress * 0.55); // 45% base + 55% for recognition
                                progressElement.style.width = `${totalProgress}%`;
                                progressText.textContent = `Texterkennung: ${progress}%`;
                                
                                updateScanStatus(side, 'loading', `OCR-Texterkennung: ${progress}%`);
                            }
                        }
                    },
                    
                    // MORE PERMISSIVE configuration for German insurance cards
                    tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZÄÖÜßabcdefghijklmnopqrstuvwxyzäöüß0123456789 ./:,-()[]',
                    tessedit_pageseg_mode: '3', // Fully automatic page segmentation (more flexible)
                    preserve_interword_spaces: '1',
                    
                    // RELAXED OCR parameters for better success rate
                    tessedit_ocr_engine_mode: '1', // Neural net LSTM engine
                    classify_enable_learning: '0',
                    
                    // German language specifics but more lenient
                    load_freq_dawg: '1',
                    load_unambig_dawg: '1',
                    user_defined_dpi: '100', // Even lower DPI for easier processing
                    tessedit_char_blacklist: '~`!@#$%^&*()+=[]{}\\|;\'"<>?'
                };

                // Single-pass OCR with better fallback
                progressText.textContent = 'Texterkennung läuft...';
                const result = await Tesseract.recognize(imageBlob, 'deu', tesseractConfig);
                
                progressText.textContent = 'Ergebnisse analysieren...';
                progressElement.style.width = '95%';
                
                // MUCH MORE LENIENT parsing - accept any reasonable text
                const combinedResult = parseOCRResultLenient(result.data.text, side, result.data.confidence);
                
                progressElement.style.width = '100%';
                progressText.textContent = 'OCR abgeschlossen!';
                
                console.log('✅ Lenient OCR completed:', combinedResult);
                return combinedResult;
                
            } catch (error) {
                console.error('OCR error:', error);
                
                if (progressBar) progressBar.style.display = 'none';
                
                // FALLBACK: Return success with minimal data to avoid blocking user
                console.log('🔄 OCR failed, using fallback success to continue workflow');
                return {
                    success: true,
                    data: {
                        name: side === 'front' ? 'Name nicht erkannt' : '',
                        insurance_number: side === 'front' ? 'Nummer nicht erkannt' : '',
                        insurance_company: side === 'front' ? 'Krankenkasse nicht erkannt' : '',
                        valid_until: side === 'back' ? 'Datum nicht erkannt' : '',
                        birth_date: ''
                    },
                    confidence: 0.5,
                    raw_text: '',
                    method: 'fallback_on_error'
                };
            }
        }
        
        // NEW: Much more lenient OCR result parsing
        function parseOCRResultLenient(text, side, confidence) {
            console.log(`🔍 Lenient parsing for ${side} side with confidence ${confidence}...`);
            console.log('Raw text:', text);
            
            // If we got any text at all, that's already success
            if (!text || text.trim().length < 5) {
                console.log('⚠️ Very little text found, using minimal fallback');
                return {
                    success: true,
                    data: {
                        name: side === 'front' ? 'Text zu kurz' : '',
                        insurance_number: side === 'front' ? 'Nicht lesbar' : '',
                        insurance_company: side === 'front' ? 'Nicht erkannt' : '',
                        valid_until: side === 'back' ? 'Nicht erkannt' : '',
                        birth_date: ''
                    },
                    confidence: Math.max(confidence / 100, 0.3),
                    raw_text: text,
                    method: 'minimal_fallback'
                };
            }
            
            const lines = text.split('\n').map(line => line.trim()).filter(line => line.length > 1);
            
            const data = {
                name: '',
                insurance_number: '',
                insurance_company: '',
                birth_date: '',
                valid_until: ''
            };
            
            // VERY LENIENT extraction - take whatever we can find
            for (const line of lines) {
                // Any text that could be a name (2+ words with letters)
                if (!data.name && /[A-Za-zÄÖÜäöüß]+\s+[A-Za-zÄÖÜäöüß]+/.test(line)) {
                    data.name = line.substring(0, 50);
                    console.log(`📝 Found potential name: ${data.name}`);
                }
                
                // Any number sequence that could be insurance number
                if (!data.insurance_number) {
                    const numberMatch = line.match(/([A-Z]?\d{8,12})/);
                    if (numberMatch) {
                        data.insurance_number = numberMatch[1];
                        console.log(`🔢 Found potential number: ${data.insurance_number}`);
                    }
                }
                
                // Any word that sounds like insurance company
                if (!data.insurance_company && line.length > 2 && line.length < 30) {
                    const hasInsuranceWords = /aok|tk|techniker|barmer|dak|kkh|bkk|ikk/i.test(line);
                    if (hasInsuranceWords) {
                        data.insurance_company = line.substring(0, 30);
                        console.log(`🏥 Found potential company: ${data.insurance_company}`);
                    }
                }
                
                // Any date-like pattern
                if (!data.valid_until) {
                    const dateMatch = line.match(/(\d{1,2}[\/.]\d{2,4})/);
                    if (dateMatch) {
                        data.valid_until = dateMatch[1];
                        console.log(`📅 Found potential date: ${data.valid_until}`);
                    }
                }
            }
            
            // Fill in missing data with generic text instead of leaving empty
            if (side === 'front') {
                if (!data.name) data.name = 'Unleserlich - bitte manuell prüfen';
                if (!data.insurance_number) data.insurance_number = 'Unleserlich - bitte manuell prüfen';
                if (!data.insurance_company) data.insurance_company = 'Unleserlich - bitte manuell prüfen';
            } else {
                if (!data.valid_until) data.valid_until = 'Unleserlich - bitte manuell prüfen';
            }
            
            console.log('✅ Lenient parsing result:', data);
            
            // Always return success - let user decide if data is good enough
            return {
                success: true,
                data: data,
                confidence: Math.max(confidence / 100, 0.4), // Boost confidence
                raw_text: text,
                method: 'lenient_parsing'
            };
        }
        
        // NEW: Combine multiple OCR results for higher accuracy
        function combineOCRResults(results, side) {
            console.log(`🔗 Combining ${results.length} OCR results for ${side} side...`);
            
            let bestText = '';
            let bestConfidence = 0;
            let allTexts = [];
            
            // Find best result by confidence
            for (const result of results) {
                allTexts.push(result.data.text);
                if (result.data.confidence > bestConfidence) {
                    bestConfidence = result.data.confidence;
                    bestText = result.data.text;
                }
            }
            
            // Parse data from all results
            const parsedResults = [];
            for (const text of allTexts) {
                const parsed = side === 'front' ? 
                    parseGermanInsuranceCardFront(text) : 
                    parseGermanInsuranceCardBack(text);
                parsedResults.push(parsed);
            }
            
            // Merge parsed data (prefer non-empty values)
            const mergedData = mergeParsedData(parsedResults);
            
            // Validate merged data
            const hasValidData = side === 'front' ?
                (mergedData.name || mergedData.insurance_number || mergedData.insurance_company) :
                (mergedData.valid_until || mergedData.birth_date);
            
            if (!hasValidData) {
                console.log('⚠️ No valid data found in any OCR result');
                
                // Fallback: try to extract any useful information
                const fallbackData = extractAnyUsefulInfo(bestText, side);
                
                if (fallbackData && Object.keys(fallbackData).length > 0) {
                    return {
                        success: true,
                        data: fallbackData,
                        confidence: Math.max(bestConfidence / 100, 0.4),
                        raw_text: bestText,
                        method: 'fallback_combined'
                    };
                }
                
                return {
                    success: false,
                    error: `Keine ${side === 'front' ? 'Vorderseite' : 'Rückseite'}-Daten erkannt. Bitte bessere Bildqualität.`,
                    confidence: bestConfidence / 100,
                    raw_text: bestText
                };
            }
            
            return {
                success: true,
                data: mergedData,
                confidence: Math.min(bestConfidence / 100 + 0.1, 0.95), // Boost confidence for combined results
                raw_text: bestText,
                method: 'enhanced_combined'
            };
        }

        // NEW: Merge multiple parsed data results
        function mergeParsedData(parsedResults) {
            const merged = {
                name: '',
                insurance_number: '',
                insurance_company: '',
                birth_date: '',
                valid_until: ''
            };
            
            // For each field, find the best (longest, most complete) value
            for (const result of parsedResults) {
                for (const [key, value] of Object.entries(result)) {
                    if (value && value.length > merged[key].length) {
                        // Additional validation for specific fields
                        if (key === 'insurance_number' && value.match(/^[A-Z]?\d{8,10}$/)) {
                            merged[key] = value;
                        } else if (key === 'name' && isValidName(value)) {
                            merged[key] = value;
                        } else if (key === 'insurance_company' && isGermanInsuranceCompany(value)) {
                            merged[key] = value;
                        } else if (key === 'birth_date' && value.match(/\d{1,2}\.\d{1,2}\.\d{2,4}/)) {
                            merged[key] = value;
                        } else if (key === 'valid_until' && value.match(/\d{1,2}[\/\.]\d{2,4}/)) {
                            merged[key] = value;
                        } else if (!merged[key]) {
                            // If no validation needed or no current value exists
                            merged[key] = value;
                        }
                    }
                }
            }
            
            console.log('✅ Merged OCR data:', merged);
            return merged;
        }
        
        // NEW: Fallback parsing for any useful information
        function extractAnyUsefulInfo(text, side) {
            console.log(`🔍 Fallback parsing for ${side} side...`);
            
            const data = {};
            const lines = text.split('\n').map(line => line.trim()).filter(line => line.length > 1);
            
            for (const line of lines) {
                // Try to find any name-like pattern
                if (!data.name && /^[A-ZÄÖÜ][a-zäöüß]+ [A-ZÄÖÜ][a-zäöüß]+/.test(line)) {
                    data.name = line.substring(0, 50); // Limit length
                    console.log(`📝 Fallback found name: ${data.name}`);
                }
                
                // Try to find any number pattern that could be insurance number
                if (!data.insurance_number) {
                    const numberMatch = line.match(/([A-Z]?\d{8,10})/);
                    if (numberMatch) {
                        data.insurance_number = numberMatch[1];
                        console.log(`🔢 Fallback found number: ${data.insurance_number}`);
                    }
                }
                
                // Try to find any date pattern
                if (!data.valid_until) {
                    const dateMatch = line.match(/(\d{1,2}[\/.]\d{2,4})/);
                    if (dateMatch) {
                        data.valid_until = dateMatch[1];
                        console.log(`📅 Found potential date: ${data.valid_until}`);
                    }
                }
                
                // Try to find insurance company names
                if (!data.insurance_company) {
                    const companies = ['AOK', 'TK', 'Techniker', 'Barmer', 'DAK', 'KKH', 'HEK', 'BKK', 'IKK'];
                    for (const company of companies) {
                        if (line.toUpperCase().includes(company)) {
                            data.insurance_company = line.substring(0, 30);
                            console.log(`🏥 Fallback found company: ${data.insurance_company}`);
                            break;
                        }
                    }
                }
            }
            
            return data;
        }
        
        // NEW: Parse German insurance card front side
        function parseGermanInsuranceCardFront(text) {
            console.log('🔍 Parsing German insurance card FRONT side...');
            
            const lines = text.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            
            const data = {
                name: '',
                insurance_number: '',
                insurance_company: '',
                birth_date: ''
            };
            
            // Front side typically contains: Name, Insurance Number, Company, Photo
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const lineLower = line.toLowerCase();
                
                // Skip headers
                if (lineLower.includes('krankenversichertenkarte') || 
                    lineLower.includes('versichertenkarte') ||
                    lineLower.includes('european health') ||
                    lineLower.includes('bundesrepublik')) {
                    continue;
                }
                
                // Name detection (usually prominent on front)
                if (!data.name && line.length > 3 && isValidName(line)) {
                    data.name = cleanText(line);
                    console.log('📝 Found name on front:', data.name);
                    continue;
                }
                
                // Insurance number (primary on front)
                const insuranceMatch = line.match(/([A-Z]\d{9}|\d{10})/);
                if (insuranceMatch && !data.insurance_number) {
                    data.insurance_number = insuranceMatch[1];
                    console.log('🔢 Found insurance number on front:', data.insurance_number);
                    continue;
                }
                
                // Insurance company (prominent on front)
                if (isGermanInsuranceCompany(line) && !data.insurance_company) {
                    data.insurance_company = cleanText(line);
                    console.log('🏥 Found insurance company on front:', data.insurance_company);
                    continue;
                }
            }
            
            console.log('✅ Parsed front side data:', data);
            return data;
        }
        
        // NEW: Parse German insurance card back side
        function parseGermanInsuranceCardBack(text) {
            console.log('🔍 Parsing German insurance card BACK side...');
            
            const lines = text.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            
            const data = {
                valid_until: '',
                birth_date: '',
                additional_info: ''
            };
            
            // Back side typically contains: Validity date, additional info
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                // Valid until patterns (more common on back)
                const validMatch = line.match(/(?:gültig bis:?\s*|bis:?\s*)?(\d{1,2}\/\d{2,4}|\d{1,2}\.\d{2,4})/i);
                if (validMatch && !data.valid_until) {
                    data.valid_until = validMatch[1];
                    console.log('⏰ Found valid until on back:', data.valid_until);
                    continue;
                }
                
                // Birth date patterns  
                const birthMatch = line.match(/(?:geb\.?:?\s*)?(\d{1,2}\.?\d{1,2}\.?\d{2,4})/i);
                if (birthMatch && !data.birth_date) {
                    data.birth_date = birthMatch[1];
                    console.log('📅 Found birth date on back:', data.birth_date);
                    continue;
                }
            }
            
            console.log('✅ Parsed back side data:', data);
            return data;
        }
        
        // Helper functions for text parsing
        function isValidName(text) {
            // Check if text looks like a person's name
            const words = text.split(' ').filter(w => w.length > 1);
            if (words.length < 2 || words.length > 4) return false;
            
            // Should contain only letters, spaces, and common German name characters
            return /^[A-Za-zÄÖÜäöüß\s\-\.]+$/.test(text) && 
                   text.length >= 3 && 
                   text.length <= 50;
        }
        
        function isGermanInsuranceCompany(text) {
            const insuranceNames = [
                'aok', 'tk', 'techniker', 'barmer', 'dak', 'kkh', 'hek', 'pronova', 'bkk',
                'ikk', 'knappschaft', 'svlfg', 'audi', 'mercedes', 'continentale',
                'debeka', 'signal', 'hansemerkur', 'nürnberger', 'württembergische'
            ];
            
            const textLower = text.toLowerCase();
            return insuranceNames.some(name => textLower.includes(name)) &&
                   text.length >= 3 && 
                   text.length <= 50;
        }
        
        function cleanText(text) {
            return text.trim()
                       .replace(/\s+/g, ' ')
                       .replace(/[^\w\säöüÄÖÜß\.\-]/g, '');
        }
        
        function mergeOCRResults(tesseractData, backendData) {
            // Merge results, preferring non-empty values
            return {
                name: tesseractData.name || backendData.name || '',
                insurance_number: tesseractData.insurance_number || backendData.insurance_number || '',
                insurance_company: tesseractData.insurance_company || backendData.insurance_company || '',
                birth_date: tesseractData.birth_date || backendData.birth_date || '',
                valid_until: tesseractData.valid_until || backendData.valid_until || ''
            };
        }
        
        // Helper function to convert blob to base64
        function blobToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }

        function showDataConfirmation() {
            console.log('🎉 Showing final data confirmation...');
            
            // Clear safety timeout since we're showing data now
            if (dataConfirmationTimeout) {
                clearTimeout(dataConfirmationTimeout);
                dataConfirmationTimeout = null;
                console.log('⏰ Safety timeout cleared - data confirmation shown');
            }
            
            // Hide scanning steps
            document.getElementById('cardScanningSteps').style.display = 'none';
            
            // Show confirmation section
            const confirmationDiv = document.getElementById('dataConfirmation');
            confirmationDiv.style.display = 'block';
            
            // Populate extracted data
            const dataDiv = document.getElementById('extractedData');
            dataDiv.innerHTML = `
                <div class="data-field">
                    <span class="data-label">Name:</span>
                    <span class="data-value">${extractedCardData.name || 'Nicht erkannt'}</span>
                </div>
                <div class="data-field">
                    <span class="data-label">Versichertennummer:</span>
                    <span class="data-value">${extractedCardData.insuranceNumber || 'Nicht erkannt'}</span>
                </div>
                <div class="data-field">
                    <span class="data-label">Krankenkasse:</span>
                    <span class="data-value">${extractedCardData.insuranceCompany || 'Nicht erkannt'}</span>
                </div>
                <div class="data-field">
                    <span class="data-label">Gültig bis:</span>
                    <span class="data-value">${extractedCardData.validUntil || 'Nicht erkannt'}</span>
                </div>
                <div class="data-field">
                    <span class="data-label">Geburtsdatum:</span>
                    <span class="data-value">${extractedCardData.birthDate || 'Nicht erkannt'}</span>
                </div>
            `;
            
            // Show success animation with confetti
            showSuccessConfetti();
            
            console.log('✅ Data confirmation displayed');
        }

        // NEW: Success confetti animation
        function showSuccessConfetti() {
            // Create confetti particles
            const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', '#ff9ff3', '#54a0ff'];
            const confettiCount = 50;
            
            for (let i = 0; i < confettiCount; i++) {
                createConfettiParticle(colors[Math.floor(Math.random() * colors.length)]);
            }
        }

        function createConfettiParticle(color) {
            const confetti = document.createElement('div');
            confetti.style.cssText = `
                position: fixed;
                width: 8px;
                height: 8px;
                background: ${color};
                pointer-events: none;
                z-index: 999;
                border-radius: 50%;
                top: -10px;
                left: ${Math.random() * 100}vw;
                animation: confettiFall ${2 + Math.random() * 3}s linear forwards;
            `;
            
            // Add confetti animation if not exists
            if (!document.querySelector('#confettiStyle')) {
                const style = document.createElement('style');
                style.id = 'confettiStyle';
                style.textContent = `
                    @keyframes confettiFall {
                        0% {
                            transform: translateY(-10px) rotateZ(0deg);
                            opacity: 1;
                        }
                        100% {
                            transform: translateY(100vh) rotateZ(720deg);
                            opacity: 0;
                        }
                    }
                `;
                document.head.appendChild(style);
            }
            
            document.body.appendChild(confetti);
            
            // Remove confetti after animation
            setTimeout(() => {
                if (confetti.parentNode) {
                    confetti.parentNode.removeChild(confetti);
                }
            }, 5000);
        }
        
        // DEBUG: Test screenshot function
        async function testScreenshot(side) {
            try {
                console.log(`🧪 Testing screenshot for ${side} side`);
                updateScanStatus(side, 'loading', 'Screenshot-Test läuft...');
                
                const imageBlob = await captureCardImageFromVideo(side);
                
                if (imageBlob) {
                    const imageUrl = URL.createObjectURL(imageBlob);
                    const imageSize = (imageBlob.size / 1024).toFixed(1);
                    
                    console.log(`✅ Screenshot erfolgreich! Größe: ${imageSize}KB`);
                    console.log(`🔗 Bild-URL:`, imageUrl);
                    
                    updateScanStatus(side, 'success', `✅ Screenshot OK (${imageSize}KB) - OCR würde jetzt starten!`);
                    
                    // Show preview in browser console for debugging
                    console.log(`📸 Screenshot Preview (${side} side):`);
                    console.log(`%c `, `
                        background-image: url(${imageUrl}); 
                        background-size: contain; 
                        background-repeat: no-repeat; 
                        width: 200px; 
                        height: 120px; 
                        border: 2px solid #4a90e2;
                    `);
                    
                    // Create a small preview overlay for the user
                    showScreenshotPreview(imageUrl, side, imageSize);
                    
                    // Reset status after preview
                    setTimeout(() => {
                        updateScanStatus(side, 'ready', `Bereit für ${side === 'front' ? 'Vorderseite' : 'Rückseite'}-Scan. Klicken Sie "Countdown starten" wenn Sie bereit sind.`);
                    }, 3000);
                    
                } else {
                    throw new Error('Screenshot fehlgeschlagen');
                }
                
            } catch (error) {
                console.error(`❌ Screenshot-Test fehlgeschlagen:`, error);
                updateScanStatus(side, 'error', `Screenshot-Test fehlgeschlagen: ${error.message}`);
                
                // Reset status after error
                setTimeout(() => {
                    updateScanStatus(side, 'ready', `Bereit für ${side === 'front' ? 'Vorderseite' : 'Rückseite'}-Scan. Klicken Sie "Countdown starten" wenn Sie bereit sind.`);
                }, 3000);
            }
        }
        
        // Show a preview of the captured screenshot to the user
        function showScreenshotPreview(imageUrl, side, imageSize) {
            // Create preview overlay
            const previewOverlay = document.createElement('div');
            previewOverlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 1000;
                animation: fadeIn 0.3s ease;
            `;
            
            previewOverlay.innerHTML = `
                <div style="
                    background: white;
                    padding: 2rem;
                    border-radius: 16px;
                    text-align: center;
                    max-width: 500px;
                    width: 90%;
                ">
                    <h3 style="color: #28a745; margin-bottom: 1rem;">📸 Screenshot erfolgreich!</h3>
                    <img src="${imageUrl}" style="
                        max-width: 100%;
                        max-height: 300px;
                        border: 2px solid #28a745;
                        border-radius: 8px;
                        margin-bottom: 1rem;
                    ">
                    <p style="color: #666; margin-bottom: 1rem;">
                        <strong>${side === 'front' ? 'Vorderseite' : 'Rückseite'}</strong> erfasst (${imageSize}KB)<br>
                        <small>Können Sie Text auf der Karte lesen?</small>
                    </p>
                    <div style="display: flex; gap: 1rem; justify-content: center;">
                        <button onclick="this.closest('div').parentNode.remove()" style="
                            background: #28a745;
                            color: white;
                            border: none;
                            padding: 0.75rem 1.5rem;
                            border-radius: 8px;
                            cursor: pointer;
                            font-size: 1rem;
                        ">
                            ✅ Bild ist gut
                        </button>
                        <button onclick="this.closest('div').parentNode.remove(); alert('💡 Tipp: Bessere Beleuchtung oder näher an die Karte gehen!')" style="
                            background: #dc3545;
                            color: white;
                            border: none;
                            padding: 0.75rem 1.5rem;
                            border-radius: 8px;
                            cursor: pointer;
                            font-size: 1rem;
                        ">
                            ❌ Text unscharf
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(previewOverlay);
            
            // Auto-remove after 15 seconds
            setTimeout(() => {
                if (previewOverlay.parentNode) {
                    previewOverlay.remove();
                }
            }, 15000);
        }

        // Umschalt-Logik für Scan/Manuell
        function showScanMode() {
            document.getElementById('scanWorkflow').style.display = '';
            document.getElementById('manualInputForm').style.display = 'none';
            document.getElementById('manualConfirmBox').style.display = 'none';
            document.getElementById('toggleScan').classList.add('btn-success');
            document.getElementById('toggleManual').classList.remove('btn-success');
            document.getElementById('toggleManual').style.background = '#6c757d';
            document.getElementById('toggleScan').style.background = '';
        }
        function showManualMode() {
            document.getElementById('scanWorkflow').style.display = 'none';
            document.getElementById('manualInputForm').style.display = '';
            document.getElementById('manualConfirmBox').style.display = 'none';
            document.getElementById('toggleManual').classList.add('btn-success');
            document.getElementById('toggleScan').classList.remove('btn-success');
            document.getElementById('toggleScan').style.background = '#6c757d';
            document.getElementById('toggleManual').style.background = '';
        }
        // Initial: Scan-Mode aktiv
        document.addEventListener('DOMContentLoaded', function() {
            showScanMode();
            // Manuelles Formular-Handling
            document.getElementById('manualInputForm').onsubmit = function(e) {
                e.preventDefault();
                // Validierung durch HTML5-Attribute, zusätzliche Checks möglich
                const kvnr = document.getElementById('manualKvnr').value.trim();
                const name = document.getElementById('manualName').value.trim();
                const birthdate = document.getElementById('manualBirthdate').value;
                const insurance = document.getElementById('manualInsurance').value.trim();
                if (!kvnr || !name || !birthdate || !insurance) {
                    alert('Bitte alle Felder ausfüllen!');
                    return false;
                }
                // Daten in Bestätigungsansicht anzeigen
                const confirmData = `
                    <div class='data-field'><span class='data-label'>KVNR:</span><span class='data-value'>${kvnr}</span></div>
                    <div class='data-field'><span class='data-label'>Name:</span><span class='data-value'>${name}</span></div>
                    <div class='data-field'><span class='data-label'>Geburtsdatum:</span><span class='data-value'>${birthdate}</span></div>
                    <div class='data-field'><span class='data-label'>Krankenkasse:</span><span class='data-value'>${insurance}</span></div>
                `;
                document.getElementById('manualConfirmData').innerHTML = confirmData;
                document.getElementById('manualInputForm').style.display = 'none';
                document.getElementById('manualConfirmBox').style.display = '';
                return false;
            };
            // Bestätigen-Button
            document.getElementById('manualConfirmBtn').onclick = function() {
                document.getElementById('step4Next').disabled = false;
                document.getElementById('manualConfirmBox').style.display = 'none';
                // Optional: Feedback anzeigen oder Step 4 als abgeschlossen markieren
            };
            // Bearbeiten-Button
            document.getElementById('manualEditBtn').onclick = function() {
                document.getElementById('manualConfirmBox').style.display = 'none';
                document.getElementById('manualInputForm').style.display = '';
            };
            // Passe die statischen Hinweise im Scan-Workflow an
            const frontScanHint = document.querySelector('#frontSideStep p');
            if (frontScanHint) {
                frontScanHint.textContent = 'Bitte halten Sie die Vorderseite Ihrer Karte bereit und klicken Sie auf "Countdown starten".';
            }
            const backScanHint = document.querySelector('#backSideStep p');
            if (backScanHint) {
                backScanHint.textContent = 'Bitte drehen Sie die Karte um, halten Sie die Rückseite bereit und klicken Sie auf "Countdown starten".';
            }
        });

        // Entferne das KI-Badge im Scan-Rahmen nach dem Laden
        function removeKIBadge() {
            document.querySelectorAll('.card-side-indicator').forEach(function(el) {
                if (el.textContent && el.textContent.toLowerCase().includes('ki')) {
                    el.style.display = 'none';
                }
            });
        }
        // Blende technische Visualisierungen aus
        function removeTechVisuals() {
            document.querySelectorAll('.enhanced-detection').forEach(function(el) {
                el.classList.remove('enhanced-detection');
            });
        }
        // Im manuellen Modus: Blende den Weiter-Button oben aus
        function hideStep4NextIfManual() {
            const manualForm = document.getElementById('manualInputForm');
            const step4Next = document.getElementById('step4Next');
            if (manualForm && step4Next) {
                if (manualForm.style.display !== 'none') {
                    step4Next.style.display = 'none';
                } else {
                    step4Next.style.display = '';
                }
            }
        }
        // Hooke in die Umschalt-Logik ein
        function showScanMode() {
            document.getElementById('scanWorkflow').style.display = '';
            document.getElementById('manualInputForm').style.display = 'none';
            document.getElementById('manualConfirmBox').style.display = 'none';
            document.getElementById('toggleScan').classList.add('btn-success');
            document.getElementById('toggleManual').classList.remove('btn-success');
            document.getElementById('toggleManual').style.background = '#6c757d';
            document.getElementById('toggleScan').style.background = '';
            hideStep4NextIfManual();
        }
        function showManualMode() {
            document.getElementById('scanWorkflow').style.display = 'none';
            document.getElementById('manualInputForm').style.display = '';
            document.getElementById('manualConfirmBox').style.display = 'none';
            document.getElementById('toggleManual').classList.add('btn-success');
            document.getElementById('toggleScan').classList.remove('btn-success');
            document.getElementById('toggleScan').style.background = '#6c757d';
            document.getElementById('toggleManual').style.background = '';
            hideStep4NextIfManual();
        }
        document.addEventListener('DOMContentLoaded', function() {
            // ... bestehender Code ...
            removeKIBadge();
            removeTechVisuals();
            hideStep4NextIfManual();
            // ... bestehender Code ...
            // Passe die statischen Hinweise im Scan-Workflow an
            const frontScanHint = document.querySelector('#frontSideStep p');
            if (frontScanHint) {
                frontScanHint.textContent = 'Bitte halten Sie die Vorderseite Ihrer Karte bereit und klicken Sie auf "Countdown starten".';
            }
            const backScanHint = document.querySelector('#backSideStep p');
            if (backScanHint) {
                backScanHint.textContent = 'Bitte drehen Sie die Karte um, halten Sie die Rückseite bereit und klicken Sie auf "Countdown starten".';
            }
        });
    </script>
</body>
</html> 